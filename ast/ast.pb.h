// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ast.proto

#ifndef PROTOBUF_ast_2eproto__INCLUDED
#define PROTOBUF_ast_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_ast_2eproto();
void protobuf_InitDefaults_ast_2eproto();
void protobuf_AssignDesc_ast_2eproto();
void protobuf_ShutdownFile_ast_2eproto();

class AssignExpr;
class BinaryOpExpr;
class Block;
class BrkStmt;
class CallExpr;
class Class;
class Class_Member;
class CondLoopStmt;
class CondStmt;
class ConstantExpr;
class ContStmt;
class Expr;
class ExprStmt;
class ExternFunc;
class Func;
class FuncParam;
class IndexExpr;
class MemberExpr;
class Module;
class Module_Member;
class RetStmt;
class Stmt;
class TypeSpec;
class UnaryOpExpr;
class VarDeclStmt;
class VarExpr;

enum UnaryOpExpr_Op {
  UnaryOpExpr_Op_UNKNOWN = 0,
  UnaryOpExpr_Op_ADD = 1,
  UnaryOpExpr_Op_SUB = 2,
  UnaryOpExpr_Op_BORROW = 3,
  UnaryOpExpr_Op_MOVE = 4,
  UnaryOpExpr_Op_UnaryOpExpr_Op_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  UnaryOpExpr_Op_UnaryOpExpr_Op_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool UnaryOpExpr_Op_IsValid(int value);
const UnaryOpExpr_Op UnaryOpExpr_Op_Op_MIN = UnaryOpExpr_Op_UNKNOWN;
const UnaryOpExpr_Op UnaryOpExpr_Op_Op_MAX = UnaryOpExpr_Op_MOVE;
const int UnaryOpExpr_Op_Op_ARRAYSIZE = UnaryOpExpr_Op_Op_MAX + 1;

const ::google::protobuf::EnumDescriptor* UnaryOpExpr_Op_descriptor();
inline const ::std::string& UnaryOpExpr_Op_Name(UnaryOpExpr_Op value) {
  return ::google::protobuf::internal::NameOfEnum(
    UnaryOpExpr_Op_descriptor(), value);
}
inline bool UnaryOpExpr_Op_Parse(
    const ::std::string& name, UnaryOpExpr_Op* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnaryOpExpr_Op>(
    UnaryOpExpr_Op_descriptor(), name, value);
}
enum BinaryOpExpr_Op {
  BinaryOpExpr_Op_UNKNOWN = 0,
  BinaryOpExpr_Op_ADD = 1,
  BinaryOpExpr_Op_SUB = 2,
  BinaryOpExpr_Op_MUL = 3,
  BinaryOpExpr_Op_DIV = 4,
  BinaryOpExpr_Op_MOD = 5,
  BinaryOpExpr_Op_EQ = 6,
  BinaryOpExpr_Op_NE = 7,
  BinaryOpExpr_Op_GT = 8,
  BinaryOpExpr_Op_GE = 9,
  BinaryOpExpr_Op_LT = 10,
  BinaryOpExpr_Op_LE = 11,
  BinaryOpExpr_Op_BinaryOpExpr_Op_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  BinaryOpExpr_Op_BinaryOpExpr_Op_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool BinaryOpExpr_Op_IsValid(int value);
const BinaryOpExpr_Op BinaryOpExpr_Op_Op_MIN = BinaryOpExpr_Op_UNKNOWN;
const BinaryOpExpr_Op BinaryOpExpr_Op_Op_MAX = BinaryOpExpr_Op_LE;
const int BinaryOpExpr_Op_Op_ARRAYSIZE = BinaryOpExpr_Op_Op_MAX + 1;

const ::google::protobuf::EnumDescriptor* BinaryOpExpr_Op_descriptor();
inline const ::std::string& BinaryOpExpr_Op_Name(BinaryOpExpr_Op value) {
  return ::google::protobuf::internal::NameOfEnum(
    BinaryOpExpr_Op_descriptor(), value);
}
inline bool BinaryOpExpr_Op_Parse(
    const ::std::string& name, BinaryOpExpr_Op* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BinaryOpExpr_Op>(
    BinaryOpExpr_Op_descriptor(), name, value);
}
enum VarDeclStmt_Mode {
  VarDeclStmt_Mode_UNKNOWN = 0,
  VarDeclStmt_Mode_OWN = 1,
  VarDeclStmt_Mode_BORROW = 2,
  VarDeclStmt_Mode_VarDeclStmt_Mode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  VarDeclStmt_Mode_VarDeclStmt_Mode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool VarDeclStmt_Mode_IsValid(int value);
const VarDeclStmt_Mode VarDeclStmt_Mode_Mode_MIN = VarDeclStmt_Mode_UNKNOWN;
const VarDeclStmt_Mode VarDeclStmt_Mode_Mode_MAX = VarDeclStmt_Mode_BORROW;
const int VarDeclStmt_Mode_Mode_ARRAYSIZE = VarDeclStmt_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* VarDeclStmt_Mode_descriptor();
inline const ::std::string& VarDeclStmt_Mode_Name(VarDeclStmt_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    VarDeclStmt_Mode_descriptor(), value);
}
inline bool VarDeclStmt_Mode_Parse(
    const ::std::string& name, VarDeclStmt_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VarDeclStmt_Mode>(
    VarDeclStmt_Mode_descriptor(), name, value);
}
enum FuncParam_Mode {
  FuncParam_Mode_UNKNOWN = 0,
  FuncParam_Mode_COPY = 1,
  FuncParam_Mode_BORROW = 2,
  FuncParam_Mode_MOVE = 3,
  FuncParam_Mode_FuncParam_Mode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  FuncParam_Mode_FuncParam_Mode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool FuncParam_Mode_IsValid(int value);
const FuncParam_Mode FuncParam_Mode_Mode_MIN = FuncParam_Mode_UNKNOWN;
const FuncParam_Mode FuncParam_Mode_Mode_MAX = FuncParam_Mode_MOVE;
const int FuncParam_Mode_Mode_ARRAYSIZE = FuncParam_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* FuncParam_Mode_descriptor();
inline const ::std::string& FuncParam_Mode_Name(FuncParam_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    FuncParam_Mode_descriptor(), value);
}
inline bool FuncParam_Mode_Parse(
    const ::std::string& name, FuncParam_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FuncParam_Mode>(
    FuncParam_Mode_descriptor(), name, value);
}
enum Func_ReturnMode {
  Func_ReturnMode_UNKNOWN = 0,
  Func_ReturnMode_COPY = 1,
  Func_ReturnMode_BORROW = 2,
  Func_ReturnMode_MOVE = 3,
  Func_ReturnMode_Func_ReturnMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Func_ReturnMode_Func_ReturnMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Func_ReturnMode_IsValid(int value);
const Func_ReturnMode Func_ReturnMode_ReturnMode_MIN = Func_ReturnMode_UNKNOWN;
const Func_ReturnMode Func_ReturnMode_ReturnMode_MAX = Func_ReturnMode_MOVE;
const int Func_ReturnMode_ReturnMode_ARRAYSIZE = Func_ReturnMode_ReturnMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Func_ReturnMode_descriptor();
inline const ::std::string& Func_ReturnMode_Name(Func_ReturnMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Func_ReturnMode_descriptor(), value);
}
inline bool Func_ReturnMode_Parse(
    const ::std::string& name, Func_ReturnMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Func_ReturnMode>(
    Func_ReturnMode_descriptor(), name, value);
}
enum Func_CC {
  Func_CC_DEFAULT = 0,
  Func_CC_C = 1,
  Func_CC_Func_CC_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Func_CC_Func_CC_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Func_CC_IsValid(int value);
const Func_CC Func_CC_CC_MIN = Func_CC_DEFAULT;
const Func_CC Func_CC_CC_MAX = Func_CC_C;
const int Func_CC_CC_ARRAYSIZE = Func_CC_CC_MAX + 1;

const ::google::protobuf::EnumDescriptor* Func_CC_descriptor();
inline const ::std::string& Func_CC_Name(Func_CC value) {
  return ::google::protobuf::internal::NameOfEnum(
    Func_CC_descriptor(), value);
}
inline bool Func_CC_Parse(
    const ::std::string& name, Func_CC* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Func_CC>(
    Func_CC_descriptor(), name, value);
}
// ===================================================================

class ConstantExpr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ConstantExpr) */ {
 public:
  ConstantExpr();
  virtual ~ConstantExpr();

  ConstantExpr(const ConstantExpr& from);

  inline ConstantExpr& operator=(const ConstantExpr& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConstantExpr& default_instance();

  enum ValueCase {
    kStringValue = 1,
    kIntValue = 2,
    kBoolValue = 3,
    VALUE_NOT_SET = 0,
  };

  static const ConstantExpr* internal_default_instance();

  void Swap(ConstantExpr* other);

  // implements Message ----------------------------------------------

  inline ConstantExpr* New() const { return New(NULL); }

  ConstantExpr* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConstantExpr& from);
  void MergeFrom(const ConstantExpr& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConstantExpr* other);
  void UnsafeMergeFrom(const ConstantExpr& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string stringValue = 1;
  private:
  bool has_stringvalue() const;
  public:
  void clear_stringvalue();
  static const int kStringValueFieldNumber = 1;
  const ::std::string& stringvalue() const;
  void set_stringvalue(const ::std::string& value);
  void set_stringvalue(const char* value);
  void set_stringvalue(const char* value, size_t size);
  ::std::string* mutable_stringvalue();
  ::std::string* release_stringvalue();
  void set_allocated_stringvalue(::std::string* stringvalue);

  // optional int64 intValue = 2;
  private:
  bool has_intvalue() const;
  public:
  void clear_intvalue();
  static const int kIntValueFieldNumber = 2;
  ::google::protobuf::int64 intvalue() const;
  void set_intvalue(::google::protobuf::int64 value);

  // optional bool boolValue = 3;
  private:
  bool has_boolvalue() const;
  public:
  void clear_boolvalue();
  static const int kBoolValueFieldNumber = 3;
  bool boolvalue() const;
  void set_boolvalue(bool value);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:ConstantExpr)
 private:
  inline void set_has_stringvalue();
  inline void set_has_intvalue();
  inline void set_has_boolvalue();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::google::protobuf::internal::ArenaStringPtr stringvalue_;
    ::google::protobuf::int64 intvalue_;
    bool boolvalue_;
  } value_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_ast_2eproto_impl();
  friend void  protobuf_AddDesc_ast_2eproto_impl();
  friend void protobuf_AssignDesc_ast_2eproto();
  friend void protobuf_ShutdownFile_ast_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ConstantExpr> ConstantExpr_default_instance_;

// -------------------------------------------------------------------

class VarExpr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:VarExpr) */ {
 public:
  VarExpr();
  virtual ~VarExpr();

  VarExpr(const VarExpr& from);

  inline VarExpr& operator=(const VarExpr& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VarExpr& default_instance();

  static const VarExpr* internal_default_instance();

  void Swap(VarExpr* other);

  // implements Message ----------------------------------------------

  inline VarExpr* New() const { return New(NULL); }

  VarExpr* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VarExpr& from);
  void MergeFrom(const VarExpr& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VarExpr* other);
  void UnsafeMergeFrom(const VarExpr& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string var = 1;
  void clear_var();
  static const int kVarFieldNumber = 1;
  const ::std::string& var() const;
  void set_var(const ::std::string& value);
  void set_var(const char* value);
  void set_var(const char* value, size_t size);
  ::std::string* mutable_var();
  ::std::string* release_var();
  void set_allocated_var(::std::string* var);

  // @@protoc_insertion_point(class_scope:VarExpr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr var_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ast_2eproto_impl();
  friend void  protobuf_AddDesc_ast_2eproto_impl();
  friend void protobuf_AssignDesc_ast_2eproto();
  friend void protobuf_ShutdownFile_ast_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<VarExpr> VarExpr_default_instance_;

// -------------------------------------------------------------------

class MemberExpr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MemberExpr) */ {
 public:
  MemberExpr();
  virtual ~MemberExpr();

  MemberExpr(const MemberExpr& from);

  inline MemberExpr& operator=(const MemberExpr& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemberExpr& default_instance();

  static const MemberExpr* internal_default_instance();

  void Swap(MemberExpr* other);

  // implements Message ----------------------------------------------

  inline MemberExpr* New() const { return New(NULL); }

  MemberExpr* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemberExpr& from);
  void MergeFrom(const MemberExpr& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MemberExpr* other);
  void UnsafeMergeFrom(const MemberExpr& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Expr expr = 1;
  bool has_expr() const;
  void clear_expr();
  static const int kExprFieldNumber = 1;
  const ::Expr& expr() const;
  ::Expr* mutable_expr();
  ::Expr* release_expr();
  void set_allocated_expr(::Expr* expr);

  // optional string member = 2;
  void clear_member();
  static const int kMemberFieldNumber = 2;
  const ::std::string& member() const;
  void set_member(const ::std::string& value);
  void set_member(const char* value);
  void set_member(const char* value, size_t size);
  ::std::string* mutable_member();
  ::std::string* release_member();
  void set_allocated_member(::std::string* member);

  // @@protoc_insertion_point(class_scope:MemberExpr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr member_;
  ::Expr* expr_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ast_2eproto_impl();
  friend void  protobuf_AddDesc_ast_2eproto_impl();
  friend void protobuf_AssignDesc_ast_2eproto();
  friend void protobuf_ShutdownFile_ast_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<MemberExpr> MemberExpr_default_instance_;

// -------------------------------------------------------------------

class IndexExpr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IndexExpr) */ {
 public:
  IndexExpr();
  virtual ~IndexExpr();

  IndexExpr(const IndexExpr& from);

  inline IndexExpr& operator=(const IndexExpr& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IndexExpr& default_instance();

  static const IndexExpr* internal_default_instance();

  void Swap(IndexExpr* other);

  // implements Message ----------------------------------------------

  inline IndexExpr* New() const { return New(NULL); }

  IndexExpr* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IndexExpr& from);
  void MergeFrom(const IndexExpr& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IndexExpr* other);
  void UnsafeMergeFrom(const IndexExpr& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Expr expr = 1;
  bool has_expr() const;
  void clear_expr();
  static const int kExprFieldNumber = 1;
  const ::Expr& expr() const;
  ::Expr* mutable_expr();
  ::Expr* release_expr();
  void set_allocated_expr(::Expr* expr);

  // optional .Expr index_expr = 2;
  bool has_index_expr() const;
  void clear_index_expr();
  static const int kIndexExprFieldNumber = 2;
  const ::Expr& index_expr() const;
  ::Expr* mutable_index_expr();
  ::Expr* release_index_expr();
  void set_allocated_index_expr(::Expr* index_expr);

  // @@protoc_insertion_point(class_scope:IndexExpr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Expr* expr_;
  ::Expr* index_expr_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ast_2eproto_impl();
  friend void  protobuf_AddDesc_ast_2eproto_impl();
  friend void protobuf_AssignDesc_ast_2eproto();
  friend void protobuf_ShutdownFile_ast_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<IndexExpr> IndexExpr_default_instance_;

// -------------------------------------------------------------------

class CallExpr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CallExpr) */ {
 public:
  CallExpr();
  virtual ~CallExpr();

  CallExpr(const CallExpr& from);

  inline CallExpr& operator=(const CallExpr& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CallExpr& default_instance();

  static const CallExpr* internal_default_instance();

  void Swap(CallExpr* other);

  // implements Message ----------------------------------------------

  inline CallExpr* New() const { return New(NULL); }

  CallExpr* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CallExpr& from);
  void MergeFrom(const CallExpr& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CallExpr* other);
  void UnsafeMergeFrom(const CallExpr& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Expr expr = 1;
  bool has_expr() const;
  void clear_expr();
  static const int kExprFieldNumber = 1;
  const ::Expr& expr() const;
  ::Expr* mutable_expr();
  ::Expr* release_expr();
  void set_allocated_expr(::Expr* expr);

  // repeated .Expr arg_exprs = 2;
  int arg_exprs_size() const;
  void clear_arg_exprs();
  static const int kArgExprsFieldNumber = 2;
  const ::Expr& arg_exprs(int index) const;
  ::Expr* mutable_arg_exprs(int index);
  ::Expr* add_arg_exprs();
  ::google::protobuf::RepeatedPtrField< ::Expr >*
      mutable_arg_exprs();
  const ::google::protobuf::RepeatedPtrField< ::Expr >&
      arg_exprs() const;

  // @@protoc_insertion_point(class_scope:CallExpr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Expr > arg_exprs_;
  ::Expr* expr_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ast_2eproto_impl();
  friend void  protobuf_AddDesc_ast_2eproto_impl();
  friend void protobuf_AssignDesc_ast_2eproto();
  friend void protobuf_ShutdownFile_ast_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<CallExpr> CallExpr_default_instance_;

// -------------------------------------------------------------------

class UnaryOpExpr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:UnaryOpExpr) */ {
 public:
  UnaryOpExpr();
  virtual ~UnaryOpExpr();

  UnaryOpExpr(const UnaryOpExpr& from);

  inline UnaryOpExpr& operator=(const UnaryOpExpr& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnaryOpExpr& default_instance();

  static const UnaryOpExpr* internal_default_instance();

  void Swap(UnaryOpExpr* other);

  // implements Message ----------------------------------------------

  inline UnaryOpExpr* New() const { return New(NULL); }

  UnaryOpExpr* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnaryOpExpr& from);
  void MergeFrom(const UnaryOpExpr& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnaryOpExpr* other);
  void UnsafeMergeFrom(const UnaryOpExpr& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UnaryOpExpr_Op Op;
  static const Op UNKNOWN =
    UnaryOpExpr_Op_UNKNOWN;
  static const Op ADD =
    UnaryOpExpr_Op_ADD;
  static const Op SUB =
    UnaryOpExpr_Op_SUB;
  static const Op BORROW =
    UnaryOpExpr_Op_BORROW;
  static const Op MOVE =
    UnaryOpExpr_Op_MOVE;
  static inline bool Op_IsValid(int value) {
    return UnaryOpExpr_Op_IsValid(value);
  }
  static const Op Op_MIN =
    UnaryOpExpr_Op_Op_MIN;
  static const Op Op_MAX =
    UnaryOpExpr_Op_Op_MAX;
  static const int Op_ARRAYSIZE =
    UnaryOpExpr_Op_Op_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Op_descriptor() {
    return UnaryOpExpr_Op_descriptor();
  }
  static inline const ::std::string& Op_Name(Op value) {
    return UnaryOpExpr_Op_Name(value);
  }
  static inline bool Op_Parse(const ::std::string& name,
      Op* value) {
    return UnaryOpExpr_Op_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .UnaryOpExpr.Op op = 1;
  void clear_op();
  static const int kOpFieldNumber = 1;
  ::UnaryOpExpr_Op op() const;
  void set_op(::UnaryOpExpr_Op value);

  // optional .Expr expr = 2;
  bool has_expr() const;
  void clear_expr();
  static const int kExprFieldNumber = 2;
  const ::Expr& expr() const;
  ::Expr* mutable_expr();
  ::Expr* release_expr();
  void set_allocated_expr(::Expr* expr);

  // @@protoc_insertion_point(class_scope:UnaryOpExpr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Expr* expr_;
  int op_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ast_2eproto_impl();
  friend void  protobuf_AddDesc_ast_2eproto_impl();
  friend void protobuf_AssignDesc_ast_2eproto();
  friend void protobuf_ShutdownFile_ast_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<UnaryOpExpr> UnaryOpExpr_default_instance_;

// -------------------------------------------------------------------

class BinaryOpExpr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BinaryOpExpr) */ {
 public:
  BinaryOpExpr();
  virtual ~BinaryOpExpr();

  BinaryOpExpr(const BinaryOpExpr& from);

  inline BinaryOpExpr& operator=(const BinaryOpExpr& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BinaryOpExpr& default_instance();

  static const BinaryOpExpr* internal_default_instance();

  void Swap(BinaryOpExpr* other);

  // implements Message ----------------------------------------------

  inline BinaryOpExpr* New() const { return New(NULL); }

  BinaryOpExpr* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BinaryOpExpr& from);
  void MergeFrom(const BinaryOpExpr& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BinaryOpExpr* other);
  void UnsafeMergeFrom(const BinaryOpExpr& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef BinaryOpExpr_Op Op;
  static const Op UNKNOWN =
    BinaryOpExpr_Op_UNKNOWN;
  static const Op ADD =
    BinaryOpExpr_Op_ADD;
  static const Op SUB =
    BinaryOpExpr_Op_SUB;
  static const Op MUL =
    BinaryOpExpr_Op_MUL;
  static const Op DIV =
    BinaryOpExpr_Op_DIV;
  static const Op MOD =
    BinaryOpExpr_Op_MOD;
  static const Op EQ =
    BinaryOpExpr_Op_EQ;
  static const Op NE =
    BinaryOpExpr_Op_NE;
  static const Op GT =
    BinaryOpExpr_Op_GT;
  static const Op GE =
    BinaryOpExpr_Op_GE;
  static const Op LT =
    BinaryOpExpr_Op_LT;
  static const Op LE =
    BinaryOpExpr_Op_LE;
  static inline bool Op_IsValid(int value) {
    return BinaryOpExpr_Op_IsValid(value);
  }
  static const Op Op_MIN =
    BinaryOpExpr_Op_Op_MIN;
  static const Op Op_MAX =
    BinaryOpExpr_Op_Op_MAX;
  static const int Op_ARRAYSIZE =
    BinaryOpExpr_Op_Op_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Op_descriptor() {
    return BinaryOpExpr_Op_descriptor();
  }
  static inline const ::std::string& Op_Name(Op value) {
    return BinaryOpExpr_Op_Name(value);
  }
  static inline bool Op_Parse(const ::std::string& name,
      Op* value) {
    return BinaryOpExpr_Op_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .BinaryOpExpr.Op op = 1;
  void clear_op();
  static const int kOpFieldNumber = 1;
  ::BinaryOpExpr_Op op() const;
  void set_op(::BinaryOpExpr_Op value);

  // optional .Expr left_expr = 2;
  bool has_left_expr() const;
  void clear_left_expr();
  static const int kLeftExprFieldNumber = 2;
  const ::Expr& left_expr() const;
  ::Expr* mutable_left_expr();
  ::Expr* release_left_expr();
  void set_allocated_left_expr(::Expr* left_expr);

  // optional .Expr right_expr = 3;
  bool has_right_expr() const;
  void clear_right_expr();
  static const int kRightExprFieldNumber = 3;
  const ::Expr& right_expr() const;
  ::Expr* mutable_right_expr();
  ::Expr* release_right_expr();
  void set_allocated_right_expr(::Expr* right_expr);

  // @@protoc_insertion_point(class_scope:BinaryOpExpr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Expr* left_expr_;
  ::Expr* right_expr_;
  int op_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ast_2eproto_impl();
  friend void  protobuf_AddDesc_ast_2eproto_impl();
  friend void protobuf_AssignDesc_ast_2eproto();
  friend void protobuf_ShutdownFile_ast_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<BinaryOpExpr> BinaryOpExpr_default_instance_;

// -------------------------------------------------------------------

class AssignExpr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AssignExpr) */ {
 public:
  AssignExpr();
  virtual ~AssignExpr();

  AssignExpr(const AssignExpr& from);

  inline AssignExpr& operator=(const AssignExpr& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AssignExpr& default_instance();

  static const AssignExpr* internal_default_instance();

  void Swap(AssignExpr* other);

  // implements Message ----------------------------------------------

  inline AssignExpr* New() const { return New(NULL); }

  AssignExpr* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssignExpr& from);
  void MergeFrom(const AssignExpr& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AssignExpr* other);
  void UnsafeMergeFrom(const AssignExpr& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Expr dest_expr = 1;
  bool has_dest_expr() const;
  void clear_dest_expr();
  static const int kDestExprFieldNumber = 1;
  const ::Expr& dest_expr() const;
  ::Expr* mutable_dest_expr();
  ::Expr* release_dest_expr();
  void set_allocated_dest_expr(::Expr* dest_expr);

  // optional .Expr value_expr = 2;
  bool has_value_expr() const;
  void clear_value_expr();
  static const int kValueExprFieldNumber = 2;
  const ::Expr& value_expr() const;
  ::Expr* mutable_value_expr();
  ::Expr* release_value_expr();
  void set_allocated_value_expr(::Expr* value_expr);

  // @@protoc_insertion_point(class_scope:AssignExpr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Expr* dest_expr_;
  ::Expr* value_expr_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ast_2eproto_impl();
  friend void  protobuf_AddDesc_ast_2eproto_impl();
  friend void protobuf_AssignDesc_ast_2eproto();
  friend void protobuf_ShutdownFile_ast_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<AssignExpr> AssignExpr_default_instance_;

// -------------------------------------------------------------------

class Expr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Expr) */ {
 public:
  Expr();
  virtual ~Expr();

  Expr(const Expr& from);

  inline Expr& operator=(const Expr& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Expr& default_instance();

  enum TypeCase {
    kConstant = 1,
    kVar = 2,
    kMember = 3,
    kIndex = 4,
    kCall = 5,
    kUnaryOp = 6,
    kBinaryOp = 7,
    kAssign = 8,
    TYPE_NOT_SET = 0,
  };

  static const Expr* internal_default_instance();

  void Swap(Expr* other);

  // implements Message ----------------------------------------------

  inline Expr* New() const { return New(NULL); }

  Expr* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Expr& from);
  void MergeFrom(const Expr& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Expr* other);
  void UnsafeMergeFrom(const Expr& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ConstantExpr constant = 1;
  bool has_constant() const;
  void clear_constant();
  static const int kConstantFieldNumber = 1;
  const ::ConstantExpr& constant() const;
  ::ConstantExpr* mutable_constant();
  ::ConstantExpr* release_constant();
  void set_allocated_constant(::ConstantExpr* constant);

  // optional .VarExpr var = 2;
  bool has_var() const;
  void clear_var();
  static const int kVarFieldNumber = 2;
  const ::VarExpr& var() const;
  ::VarExpr* mutable_var();
  ::VarExpr* release_var();
  void set_allocated_var(::VarExpr* var);

  // optional .MemberExpr member = 3;
  bool has_member() const;
  void clear_member();
  static const int kMemberFieldNumber = 3;
  const ::MemberExpr& member() const;
  ::MemberExpr* mutable_member();
  ::MemberExpr* release_member();
  void set_allocated_member(::MemberExpr* member);

  // optional .IndexExpr index = 4;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 4;
  const ::IndexExpr& index() const;
  ::IndexExpr* mutable_index();
  ::IndexExpr* release_index();
  void set_allocated_index(::IndexExpr* index);

  // optional .CallExpr call = 5;
  bool has_call() const;
  void clear_call();
  static const int kCallFieldNumber = 5;
  const ::CallExpr& call() const;
  ::CallExpr* mutable_call();
  ::CallExpr* release_call();
  void set_allocated_call(::CallExpr* call);

  // optional .UnaryOpExpr unary_op = 6;
  bool has_unary_op() const;
  void clear_unary_op();
  static const int kUnaryOpFieldNumber = 6;
  const ::UnaryOpExpr& unary_op() const;
  ::UnaryOpExpr* mutable_unary_op();
  ::UnaryOpExpr* release_unary_op();
  void set_allocated_unary_op(::UnaryOpExpr* unary_op);

  // optional .BinaryOpExpr binary_op = 7;
  bool has_binary_op() const;
  void clear_binary_op();
  static const int kBinaryOpFieldNumber = 7;
  const ::BinaryOpExpr& binary_op() const;
  ::BinaryOpExpr* mutable_binary_op();
  ::BinaryOpExpr* release_binary_op();
  void set_allocated_binary_op(::BinaryOpExpr* binary_op);

  // optional .AssignExpr assign = 8;
  bool has_assign() const;
  void clear_assign();
  static const int kAssignFieldNumber = 8;
  const ::AssignExpr& assign() const;
  ::AssignExpr* mutable_assign();
  ::AssignExpr* release_assign();
  void set_allocated_assign(::AssignExpr* assign);

  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:Expr)
 private:
  inline void set_has_constant();
  inline void set_has_var();
  inline void set_has_member();
  inline void set_has_index();
  inline void set_has_call();
  inline void set_has_unary_op();
  inline void set_has_binary_op();
  inline void set_has_assign();

  inline bool has_type() const;
  void clear_type();
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union TypeUnion {
    TypeUnion() {}
    ::ConstantExpr* constant_;
    ::VarExpr* var_;
    ::MemberExpr* member_;
    ::IndexExpr* index_;
    ::CallExpr* call_;
    ::UnaryOpExpr* unary_op_;
    ::BinaryOpExpr* binary_op_;
    ::AssignExpr* assign_;
  } type_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_ast_2eproto_impl();
  friend void  protobuf_AddDesc_ast_2eproto_impl();
  friend void protobuf_AssignDesc_ast_2eproto();
  friend void protobuf_ShutdownFile_ast_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Expr> Expr_default_instance_;

// -------------------------------------------------------------------

class ExprStmt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ExprStmt) */ {
 public:
  ExprStmt();
  virtual ~ExprStmt();

  ExprStmt(const ExprStmt& from);

  inline ExprStmt& operator=(const ExprStmt& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExprStmt& default_instance();

  static const ExprStmt* internal_default_instance();

  void Swap(ExprStmt* other);

  // implements Message ----------------------------------------------

  inline ExprStmt* New() const { return New(NULL); }

  ExprStmt* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExprStmt& from);
  void MergeFrom(const ExprStmt& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExprStmt* other);
  void UnsafeMergeFrom(const ExprStmt& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Expr expr = 1;
  bool has_expr() const;
  void clear_expr();
  static const int kExprFieldNumber = 1;
  const ::Expr& expr() const;
  ::Expr* mutable_expr();
  ::Expr* release_expr();
  void set_allocated_expr(::Expr* expr);

  // @@protoc_insertion_point(class_scope:ExprStmt)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Expr* expr_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ast_2eproto_impl();
  friend void  protobuf_AddDesc_ast_2eproto_impl();
  friend void protobuf_AssignDesc_ast_2eproto();
  friend void protobuf_ShutdownFile_ast_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ExprStmt> ExprStmt_default_instance_;

// -------------------------------------------------------------------

class RetStmt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RetStmt) */ {
 public:
  RetStmt();
  virtual ~RetStmt();

  RetStmt(const RetStmt& from);

  inline RetStmt& operator=(const RetStmt& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RetStmt& default_instance();

  static const RetStmt* internal_default_instance();

  void Swap(RetStmt* other);

  // implements Message ----------------------------------------------

  inline RetStmt* New() const { return New(NULL); }

  RetStmt* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RetStmt& from);
  void MergeFrom(const RetStmt& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RetStmt* other);
  void UnsafeMergeFrom(const RetStmt& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Expr expr = 1;
  bool has_expr() const;
  void clear_expr();
  static const int kExprFieldNumber = 1;
  const ::Expr& expr() const;
  ::Expr* mutable_expr();
  ::Expr* release_expr();
  void set_allocated_expr(::Expr* expr);

  // @@protoc_insertion_point(class_scope:RetStmt)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Expr* expr_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ast_2eproto_impl();
  friend void  protobuf_AddDesc_ast_2eproto_impl();
  friend void protobuf_AssignDesc_ast_2eproto();
  friend void protobuf_ShutdownFile_ast_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<RetStmt> RetStmt_default_instance_;

// -------------------------------------------------------------------

class BrkStmt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BrkStmt) */ {
 public:
  BrkStmt();
  virtual ~BrkStmt();

  BrkStmt(const BrkStmt& from);

  inline BrkStmt& operator=(const BrkStmt& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BrkStmt& default_instance();

  static const BrkStmt* internal_default_instance();

  void Swap(BrkStmt* other);

  // implements Message ----------------------------------------------

  inline BrkStmt* New() const { return New(NULL); }

  BrkStmt* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BrkStmt& from);
  void MergeFrom(const BrkStmt& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BrkStmt* other);
  void UnsafeMergeFrom(const BrkStmt& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:BrkStmt)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ast_2eproto_impl();
  friend void  protobuf_AddDesc_ast_2eproto_impl();
  friend void protobuf_AssignDesc_ast_2eproto();
  friend void protobuf_ShutdownFile_ast_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<BrkStmt> BrkStmt_default_instance_;

// -------------------------------------------------------------------

class ContStmt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ContStmt) */ {
 public:
  ContStmt();
  virtual ~ContStmt();

  ContStmt(const ContStmt& from);

  inline ContStmt& operator=(const ContStmt& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContStmt& default_instance();

  static const ContStmt* internal_default_instance();

  void Swap(ContStmt* other);

  // implements Message ----------------------------------------------

  inline ContStmt* New() const { return New(NULL); }

  ContStmt* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContStmt& from);
  void MergeFrom(const ContStmt& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ContStmt* other);
  void UnsafeMergeFrom(const ContStmt& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ContStmt)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ast_2eproto_impl();
  friend void  protobuf_AddDesc_ast_2eproto_impl();
  friend void protobuf_AssignDesc_ast_2eproto();
  friend void protobuf_ShutdownFile_ast_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ContStmt> ContStmt_default_instance_;

// -------------------------------------------------------------------

class CondStmt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CondStmt) */ {
 public:
  CondStmt();
  virtual ~CondStmt();

  CondStmt(const CondStmt& from);

  inline CondStmt& operator=(const CondStmt& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CondStmt& default_instance();

  static const CondStmt* internal_default_instance();

  void Swap(CondStmt* other);

  // implements Message ----------------------------------------------

  inline CondStmt* New() const { return New(NULL); }

  CondStmt* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CondStmt& from);
  void MergeFrom(const CondStmt& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CondStmt* other);
  void UnsafeMergeFrom(const CondStmt& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Expr cond_expr = 1;
  bool has_cond_expr() const;
  void clear_cond_expr();
  static const int kCondExprFieldNumber = 1;
  const ::Expr& cond_expr() const;
  ::Expr* mutable_cond_expr();
  ::Expr* release_cond_expr();
  void set_allocated_cond_expr(::Expr* cond_expr);

  // optional .Block true_block = 2;
  bool has_true_block() const;
  void clear_true_block();
  static const int kTrueBlockFieldNumber = 2;
  const ::Block& true_block() const;
  ::Block* mutable_true_block();
  ::Block* release_true_block();
  void set_allocated_true_block(::Block* true_block);

  // optional .Block false_block = 3;
  bool has_false_block() const;
  void clear_false_block();
  static const int kFalseBlockFieldNumber = 3;
  const ::Block& false_block() const;
  ::Block* mutable_false_block();
  ::Block* release_false_block();
  void set_allocated_false_block(::Block* false_block);

  // @@protoc_insertion_point(class_scope:CondStmt)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Expr* cond_expr_;
  ::Block* true_block_;
  ::Block* false_block_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ast_2eproto_impl();
  friend void  protobuf_AddDesc_ast_2eproto_impl();
  friend void protobuf_AssignDesc_ast_2eproto();
  friend void protobuf_ShutdownFile_ast_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<CondStmt> CondStmt_default_instance_;

// -------------------------------------------------------------------

class CondLoopStmt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CondLoopStmt) */ {
 public:
  CondLoopStmt();
  virtual ~CondLoopStmt();

  CondLoopStmt(const CondLoopStmt& from);

  inline CondLoopStmt& operator=(const CondLoopStmt& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CondLoopStmt& default_instance();

  static const CondLoopStmt* internal_default_instance();

  void Swap(CondLoopStmt* other);

  // implements Message ----------------------------------------------

  inline CondLoopStmt* New() const { return New(NULL); }

  CondLoopStmt* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CondLoopStmt& from);
  void MergeFrom(const CondLoopStmt& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CondLoopStmt* other);
  void UnsafeMergeFrom(const CondLoopStmt& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Expr cond_expr = 1;
  bool has_cond_expr() const;
  void clear_cond_expr();
  static const int kCondExprFieldNumber = 1;
  const ::Expr& cond_expr() const;
  ::Expr* mutable_cond_expr();
  ::Expr* release_cond_expr();
  void set_allocated_cond_expr(::Expr* cond_expr);

  // optional .Block block = 2;
  bool has_block() const;
  void clear_block();
  static const int kBlockFieldNumber = 2;
  const ::Block& block() const;
  ::Block* mutable_block();
  ::Block* release_block();
  void set_allocated_block(::Block* block);

  // @@protoc_insertion_point(class_scope:CondLoopStmt)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Expr* cond_expr_;
  ::Block* block_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ast_2eproto_impl();
  friend void  protobuf_AddDesc_ast_2eproto_impl();
  friend void protobuf_AssignDesc_ast_2eproto();
  friend void protobuf_ShutdownFile_ast_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<CondLoopStmt> CondLoopStmt_default_instance_;

// -------------------------------------------------------------------

class VarDeclStmt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:VarDeclStmt) */ {
 public:
  VarDeclStmt();
  virtual ~VarDeclStmt();

  VarDeclStmt(const VarDeclStmt& from);

  inline VarDeclStmt& operator=(const VarDeclStmt& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VarDeclStmt& default_instance();

  static const VarDeclStmt* internal_default_instance();

  void Swap(VarDeclStmt* other);

  // implements Message ----------------------------------------------

  inline VarDeclStmt* New() const { return New(NULL); }

  VarDeclStmt* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VarDeclStmt& from);
  void MergeFrom(const VarDeclStmt& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VarDeclStmt* other);
  void UnsafeMergeFrom(const VarDeclStmt& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef VarDeclStmt_Mode Mode;
  static const Mode UNKNOWN =
    VarDeclStmt_Mode_UNKNOWN;
  static const Mode OWN =
    VarDeclStmt_Mode_OWN;
  static const Mode BORROW =
    VarDeclStmt_Mode_BORROW;
  static inline bool Mode_IsValid(int value) {
    return VarDeclStmt_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    VarDeclStmt_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    VarDeclStmt_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    VarDeclStmt_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return VarDeclStmt_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return VarDeclStmt_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return VarDeclStmt_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .TypeSpec type_spec = 2;
  bool has_type_spec() const;
  void clear_type_spec();
  static const int kTypeSpecFieldNumber = 2;
  const ::TypeSpec& type_spec() const;
  ::TypeSpec* mutable_type_spec();
  ::TypeSpec* release_type_spec();
  void set_allocated_type_spec(::TypeSpec* type_spec);

  // optional .VarDeclStmt.Mode mode = 3;
  void clear_mode();
  static const int kModeFieldNumber = 3;
  ::VarDeclStmt_Mode mode() const;
  void set_mode(::VarDeclStmt_Mode value);

  // optional .Expr init_expr = 4;
  bool has_init_expr() const;
  void clear_init_expr();
  static const int kInitExprFieldNumber = 4;
  const ::Expr& init_expr() const;
  ::Expr* mutable_init_expr();
  ::Expr* release_init_expr();
  void set_allocated_init_expr(::Expr* init_expr);

  // @@protoc_insertion_point(class_scope:VarDeclStmt)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::TypeSpec* type_spec_;
  ::Expr* init_expr_;
  int mode_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ast_2eproto_impl();
  friend void  protobuf_AddDesc_ast_2eproto_impl();
  friend void protobuf_AssignDesc_ast_2eproto();
  friend void protobuf_ShutdownFile_ast_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<VarDeclStmt> VarDeclStmt_default_instance_;

// -------------------------------------------------------------------

class Stmt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Stmt) */ {
 public:
  Stmt();
  virtual ~Stmt();

  Stmt(const Stmt& from);

  inline Stmt& operator=(const Stmt& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Stmt& default_instance();

  enum TypeCase {
    kExpr = 1,
    kRet = 2,
    kBrk = 3,
    kCont = 4,
    kCond = 5,
    kCondLoop = 6,
    kVarDecl = 7,
    TYPE_NOT_SET = 0,
  };

  static const Stmt* internal_default_instance();

  void Swap(Stmt* other);

  // implements Message ----------------------------------------------

  inline Stmt* New() const { return New(NULL); }

  Stmt* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stmt& from);
  void MergeFrom(const Stmt& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Stmt* other);
  void UnsafeMergeFrom(const Stmt& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ExprStmt expr = 1;
  bool has_expr() const;
  void clear_expr();
  static const int kExprFieldNumber = 1;
  const ::ExprStmt& expr() const;
  ::ExprStmt* mutable_expr();
  ::ExprStmt* release_expr();
  void set_allocated_expr(::ExprStmt* expr);

  // optional .RetStmt ret = 2;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 2;
  const ::RetStmt& ret() const;
  ::RetStmt* mutable_ret();
  ::RetStmt* release_ret();
  void set_allocated_ret(::RetStmt* ret);

  // optional .BrkStmt brk = 3;
  bool has_brk() const;
  void clear_brk();
  static const int kBrkFieldNumber = 3;
  const ::BrkStmt& brk() const;
  ::BrkStmt* mutable_brk();
  ::BrkStmt* release_brk();
  void set_allocated_brk(::BrkStmt* brk);

  // optional .ContStmt cont = 4;
  bool has_cont() const;
  void clear_cont();
  static const int kContFieldNumber = 4;
  const ::ContStmt& cont() const;
  ::ContStmt* mutable_cont();
  ::ContStmt* release_cont();
  void set_allocated_cont(::ContStmt* cont);

  // optional .CondStmt cond = 5;
  bool has_cond() const;
  void clear_cond();
  static const int kCondFieldNumber = 5;
  const ::CondStmt& cond() const;
  ::CondStmt* mutable_cond();
  ::CondStmt* release_cond();
  void set_allocated_cond(::CondStmt* cond);

  // optional .CondLoopStmt cond_loop = 6;
  bool has_cond_loop() const;
  void clear_cond_loop();
  static const int kCondLoopFieldNumber = 6;
  const ::CondLoopStmt& cond_loop() const;
  ::CondLoopStmt* mutable_cond_loop();
  ::CondLoopStmt* release_cond_loop();
  void set_allocated_cond_loop(::CondLoopStmt* cond_loop);

  // optional .VarDeclStmt var_decl = 7;
  bool has_var_decl() const;
  void clear_var_decl();
  static const int kVarDeclFieldNumber = 7;
  const ::VarDeclStmt& var_decl() const;
  ::VarDeclStmt* mutable_var_decl();
  ::VarDeclStmt* release_var_decl();
  void set_allocated_var_decl(::VarDeclStmt* var_decl);

  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:Stmt)
 private:
  inline void set_has_expr();
  inline void set_has_ret();
  inline void set_has_brk();
  inline void set_has_cont();
  inline void set_has_cond();
  inline void set_has_cond_loop();
  inline void set_has_var_decl();

  inline bool has_type() const;
  void clear_type();
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union TypeUnion {
    TypeUnion() {}
    ::ExprStmt* expr_;
    ::RetStmt* ret_;
    ::BrkStmt* brk_;
    ::ContStmt* cont_;
    ::CondStmt* cond_;
    ::CondLoopStmt* cond_loop_;
    ::VarDeclStmt* var_decl_;
  } type_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_ast_2eproto_impl();
  friend void  protobuf_AddDesc_ast_2eproto_impl();
  friend void protobuf_AssignDesc_ast_2eproto();
  friend void protobuf_ShutdownFile_ast_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Stmt> Stmt_default_instance_;

// -------------------------------------------------------------------

class Block : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Block) */ {
 public:
  Block();
  virtual ~Block();

  Block(const Block& from);

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Block& default_instance();

  static const Block* internal_default_instance();

  void Swap(Block* other);

  // implements Message ----------------------------------------------

  inline Block* New() const { return New(NULL); }

  Block* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Block* other);
  void UnsafeMergeFrom(const Block& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Stmt stmts = 1;
  int stmts_size() const;
  void clear_stmts();
  static const int kStmtsFieldNumber = 1;
  const ::Stmt& stmts(int index) const;
  ::Stmt* mutable_stmts(int index);
  ::Stmt* add_stmts();
  ::google::protobuf::RepeatedPtrField< ::Stmt >*
      mutable_stmts();
  const ::google::protobuf::RepeatedPtrField< ::Stmt >&
      stmts() const;

  // @@protoc_insertion_point(class_scope:Block)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Stmt > stmts_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ast_2eproto_impl();
  friend void  protobuf_AddDesc_ast_2eproto_impl();
  friend void protobuf_AssignDesc_ast_2eproto();
  friend void protobuf_ShutdownFile_ast_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Block> Block_default_instance_;

// -------------------------------------------------------------------

class FuncParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FuncParam) */ {
 public:
  FuncParam();
  virtual ~FuncParam();

  FuncParam(const FuncParam& from);

  inline FuncParam& operator=(const FuncParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FuncParam& default_instance();

  static const FuncParam* internal_default_instance();

  void Swap(FuncParam* other);

  // implements Message ----------------------------------------------

  inline FuncParam* New() const { return New(NULL); }

  FuncParam* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FuncParam& from);
  void MergeFrom(const FuncParam& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FuncParam* other);
  void UnsafeMergeFrom(const FuncParam& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FuncParam_Mode Mode;
  static const Mode UNKNOWN =
    FuncParam_Mode_UNKNOWN;
  static const Mode COPY =
    FuncParam_Mode_COPY;
  static const Mode BORROW =
    FuncParam_Mode_BORROW;
  static const Mode MOVE =
    FuncParam_Mode_MOVE;
  static inline bool Mode_IsValid(int value) {
    return FuncParam_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    FuncParam_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    FuncParam_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    FuncParam_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return FuncParam_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return FuncParam_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return FuncParam_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .FuncParam.Mode mode = 2;
  void clear_mode();
  static const int kModeFieldNumber = 2;
  ::FuncParam_Mode mode() const;
  void set_mode(::FuncParam_Mode value);

  // optional .TypeSpec type_spec = 3;
  bool has_type_spec() const;
  void clear_type_spec();
  static const int kTypeSpecFieldNumber = 3;
  const ::TypeSpec& type_spec() const;
  ::TypeSpec* mutable_type_spec();
  ::TypeSpec* release_type_spec();
  void set_allocated_type_spec(::TypeSpec* type_spec);

  // optional .Expr init_expr = 4;
  bool has_init_expr() const;
  void clear_init_expr();
  static const int kInitExprFieldNumber = 4;
  const ::Expr& init_expr() const;
  ::Expr* mutable_init_expr();
  ::Expr* release_init_expr();
  void set_allocated_init_expr(::Expr* init_expr);

  // @@protoc_insertion_point(class_scope:FuncParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::TypeSpec* type_spec_;
  ::Expr* init_expr_;
  int mode_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ast_2eproto_impl();
  friend void  protobuf_AddDesc_ast_2eproto_impl();
  friend void protobuf_AssignDesc_ast_2eproto();
  friend void protobuf_ShutdownFile_ast_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<FuncParam> FuncParam_default_instance_;

// -------------------------------------------------------------------

class Func : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Func) */ {
 public:
  Func();
  virtual ~Func();

  Func(const Func& from);

  inline Func& operator=(const Func& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Func& default_instance();

  static const Func* internal_default_instance();

  void Swap(Func* other);

  // implements Message ----------------------------------------------

  inline Func* New() const { return New(NULL); }

  Func* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Func& from);
  void MergeFrom(const Func& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Func* other);
  void UnsafeMergeFrom(const Func& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Func_ReturnMode ReturnMode;
  static const ReturnMode UNKNOWN =
    Func_ReturnMode_UNKNOWN;
  static const ReturnMode COPY =
    Func_ReturnMode_COPY;
  static const ReturnMode BORROW =
    Func_ReturnMode_BORROW;
  static const ReturnMode MOVE =
    Func_ReturnMode_MOVE;
  static inline bool ReturnMode_IsValid(int value) {
    return Func_ReturnMode_IsValid(value);
  }
  static const ReturnMode ReturnMode_MIN =
    Func_ReturnMode_ReturnMode_MIN;
  static const ReturnMode ReturnMode_MAX =
    Func_ReturnMode_ReturnMode_MAX;
  static const int ReturnMode_ARRAYSIZE =
    Func_ReturnMode_ReturnMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ReturnMode_descriptor() {
    return Func_ReturnMode_descriptor();
  }
  static inline const ::std::string& ReturnMode_Name(ReturnMode value) {
    return Func_ReturnMode_Name(value);
  }
  static inline bool ReturnMode_Parse(const ::std::string& name,
      ReturnMode* value) {
    return Func_ReturnMode_Parse(name, value);
  }

  typedef Func_CC CC;
  static const CC DEFAULT =
    Func_CC_DEFAULT;
  static const CC C =
    Func_CC_C;
  static inline bool CC_IsValid(int value) {
    return Func_CC_IsValid(value);
  }
  static const CC CC_MIN =
    Func_CC_CC_MIN;
  static const CC CC_MAX =
    Func_CC_CC_MAX;
  static const int CC_ARRAYSIZE =
    Func_CC_CC_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CC_descriptor() {
    return Func_CC_descriptor();
  }
  static inline const ::std::string& CC_Name(CC value) {
    return Func_CC_Name(value);
  }
  static inline bool CC_Parse(const ::std::string& name,
      CC* value) {
    return Func_CC_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated string type_params = 2;
  int type_params_size() const;
  void clear_type_params();
  static const int kTypeParamsFieldNumber = 2;
  const ::std::string& type_params(int index) const;
  ::std::string* mutable_type_params(int index);
  void set_type_params(int index, const ::std::string& value);
  void set_type_params(int index, const char* value);
  void set_type_params(int index, const char* value, size_t size);
  ::std::string* add_type_params();
  void add_type_params(const ::std::string& value);
  void add_type_params(const char* value);
  void add_type_params(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& type_params() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_type_params();

  // optional .FuncParam params = 3;
  bool has_params() const;
  void clear_params();
  static const int kParamsFieldNumber = 3;
  const ::FuncParam& params() const;
  ::FuncParam* mutable_params();
  ::FuncParam* release_params();
  void set_allocated_params(::FuncParam* params);

  // optional .TypeSpec return_type_spec = 4;
  bool has_return_type_spec() const;
  void clear_return_type_spec();
  static const int kReturnTypeSpecFieldNumber = 4;
  const ::TypeSpec& return_type_spec() const;
  ::TypeSpec* mutable_return_type_spec();
  ::TypeSpec* release_return_type_spec();
  void set_allocated_return_type_spec(::TypeSpec* return_type_spec);

  // optional .Func.ReturnMode return_mode = 5;
  void clear_return_mode();
  static const int kReturnModeFieldNumber = 5;
  ::Func_ReturnMode return_mode() const;
  void set_return_mode(::Func_ReturnMode value);

  // optional .Func.CC cc = 6;
  void clear_cc();
  static const int kCcFieldNumber = 6;
  ::Func_CC cc() const;
  void set_cc(::Func_CC value);

  // optional .Block block = 7;
  bool has_block() const;
  void clear_block();
  static const int kBlockFieldNumber = 7;
  const ::Block& block() const;
  ::Block* mutable_block();
  ::Block* release_block();
  void set_allocated_block(::Block* block);

  // @@protoc_insertion_point(class_scope:Func)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> type_params_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::FuncParam* params_;
  ::TypeSpec* return_type_spec_;
  ::Block* block_;
  int return_mode_;
  int cc_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ast_2eproto_impl();
  friend void  protobuf_AddDesc_ast_2eproto_impl();
  friend void protobuf_AssignDesc_ast_2eproto();
  friend void protobuf_ShutdownFile_ast_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Func> Func_default_instance_;

// -------------------------------------------------------------------

class ExternFunc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ExternFunc) */ {
 public:
  ExternFunc();
  virtual ~ExternFunc();

  ExternFunc(const ExternFunc& from);

  inline ExternFunc& operator=(const ExternFunc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExternFunc& default_instance();

  static const ExternFunc* internal_default_instance();

  void Swap(ExternFunc* other);

  // implements Message ----------------------------------------------

  inline ExternFunc* New() const { return New(NULL); }

  ExternFunc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExternFunc& from);
  void MergeFrom(const ExternFunc& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExternFunc* other);
  void UnsafeMergeFrom(const ExternFunc& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .FuncParam params = 2;
  int params_size() const;
  void clear_params();
  static const int kParamsFieldNumber = 2;
  const ::FuncParam& params(int index) const;
  ::FuncParam* mutable_params(int index);
  ::FuncParam* add_params();
  ::google::protobuf::RepeatedPtrField< ::FuncParam >*
      mutable_params();
  const ::google::protobuf::RepeatedPtrField< ::FuncParam >&
      params() const;

  // optional .TypeSpec return_type_spec = 3;
  bool has_return_type_spec() const;
  void clear_return_type_spec();
  static const int kReturnTypeSpecFieldNumber = 3;
  const ::TypeSpec& return_type_spec() const;
  ::TypeSpec* mutable_return_type_spec();
  ::TypeSpec* release_return_type_spec();
  void set_allocated_return_type_spec(::TypeSpec* return_type_spec);

  // @@protoc_insertion_point(class_scope:ExternFunc)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::FuncParam > params_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::TypeSpec* return_type_spec_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ast_2eproto_impl();
  friend void  protobuf_AddDesc_ast_2eproto_impl();
  friend void protobuf_AssignDesc_ast_2eproto();
  friend void protobuf_ShutdownFile_ast_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ExternFunc> ExternFunc_default_instance_;

// -------------------------------------------------------------------

class Class_Member : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Class.Member) */ {
 public:
  Class_Member();
  virtual ~Class_Member();

  Class_Member(const Class_Member& from);

  inline Class_Member& operator=(const Class_Member& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Class_Member& default_instance();

  enum TypeCase {
    kCls = 1,
    kFunc = 2,
    kVarDecl = 3,
    TYPE_NOT_SET = 0,
  };

  static const Class_Member* internal_default_instance();

  void Swap(Class_Member* other);

  // implements Message ----------------------------------------------

  inline Class_Member* New() const { return New(NULL); }

  Class_Member* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Class_Member& from);
  void MergeFrom(const Class_Member& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Class_Member* other);
  void UnsafeMergeFrom(const Class_Member& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Class cls = 1;
  bool has_cls() const;
  void clear_cls();
  static const int kClsFieldNumber = 1;
  const ::Class& cls() const;
  ::Class* mutable_cls();
  ::Class* release_cls();
  void set_allocated_cls(::Class* cls);

  // optional .Func func = 2;
  bool has_func() const;
  void clear_func();
  static const int kFuncFieldNumber = 2;
  const ::Func& func() const;
  ::Func* mutable_func();
  ::Func* release_func();
  void set_allocated_func(::Func* func);

  // optional .VarDeclStmt var_decl = 3;
  bool has_var_decl() const;
  void clear_var_decl();
  static const int kVarDeclFieldNumber = 3;
  const ::VarDeclStmt& var_decl() const;
  ::VarDeclStmt* mutable_var_decl();
  ::VarDeclStmt* release_var_decl();
  void set_allocated_var_decl(::VarDeclStmt* var_decl);

  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:Class.Member)
 private:
  inline void set_has_cls();
  inline void set_has_func();
  inline void set_has_var_decl();

  inline bool has_type() const;
  void clear_type();
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union TypeUnion {
    TypeUnion() {}
    ::Class* cls_;
    ::Func* func_;
    ::VarDeclStmt* var_decl_;
  } type_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_ast_2eproto_impl();
  friend void  protobuf_AddDesc_ast_2eproto_impl();
  friend void protobuf_AssignDesc_ast_2eproto();
  friend void protobuf_ShutdownFile_ast_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Class_Member> Class_Member_default_instance_;

// -------------------------------------------------------------------

class Class : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Class) */ {
 public:
  Class();
  virtual ~Class();

  Class(const Class& from);

  inline Class& operator=(const Class& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Class& default_instance();

  static const Class* internal_default_instance();

  void Swap(Class* other);

  // implements Message ----------------------------------------------

  inline Class* New() const { return New(NULL); }

  Class* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Class& from);
  void MergeFrom(const Class& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Class* other);
  void UnsafeMergeFrom(const Class& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Class_Member Member;

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated string type_params = 2;
  int type_params_size() const;
  void clear_type_params();
  static const int kTypeParamsFieldNumber = 2;
  const ::std::string& type_params(int index) const;
  ::std::string* mutable_type_params(int index);
  void set_type_params(int index, const ::std::string& value);
  void set_type_params(int index, const char* value);
  void set_type_params(int index, const char* value, size_t size);
  ::std::string* add_type_params();
  void add_type_params(const ::std::string& value);
  void add_type_params(const char* value);
  void add_type_params(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& type_params() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_type_params();

  // repeated string super_classes = 3;
  int super_classes_size() const;
  void clear_super_classes();
  static const int kSuperClassesFieldNumber = 3;
  const ::std::string& super_classes(int index) const;
  ::std::string* mutable_super_classes(int index);
  void set_super_classes(int index, const ::std::string& value);
  void set_super_classes(int index, const char* value);
  void set_super_classes(int index, const char* value, size_t size);
  ::std::string* add_super_classes();
  void add_super_classes(const ::std::string& value);
  void add_super_classes(const char* value);
  void add_super_classes(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& super_classes() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_super_classes();

  // repeated .Class.Member members = 4;
  int members_size() const;
  void clear_members();
  static const int kMembersFieldNumber = 4;
  const ::Class_Member& members(int index) const;
  ::Class_Member* mutable_members(int index);
  ::Class_Member* add_members();
  ::google::protobuf::RepeatedPtrField< ::Class_Member >*
      mutable_members();
  const ::google::protobuf::RepeatedPtrField< ::Class_Member >&
      members() const;

  // @@protoc_insertion_point(class_scope:Class)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> type_params_;
  ::google::protobuf::RepeatedPtrField< ::std::string> super_classes_;
  ::google::protobuf::RepeatedPtrField< ::Class_Member > members_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ast_2eproto_impl();
  friend void  protobuf_AddDesc_ast_2eproto_impl();
  friend void protobuf_AssignDesc_ast_2eproto();
  friend void protobuf_ShutdownFile_ast_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Class> Class_default_instance_;

// -------------------------------------------------------------------

class Module_Member : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Module.Member) */ {
 public:
  Module_Member();
  virtual ~Module_Member();

  Module_Member(const Module_Member& from);

  inline Module_Member& operator=(const Module_Member& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Module_Member& default_instance();

  enum TypeCase {
    kCls = 1,
    kFunc = 2,
    kVarDecl = 3,
    kExternFunc = 4,
    TYPE_NOT_SET = 0,
  };

  static const Module_Member* internal_default_instance();

  void Swap(Module_Member* other);

  // implements Message ----------------------------------------------

  inline Module_Member* New() const { return New(NULL); }

  Module_Member* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Module_Member& from);
  void MergeFrom(const Module_Member& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Module_Member* other);
  void UnsafeMergeFrom(const Module_Member& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Class cls = 1;
  bool has_cls() const;
  void clear_cls();
  static const int kClsFieldNumber = 1;
  const ::Class& cls() const;
  ::Class* mutable_cls();
  ::Class* release_cls();
  void set_allocated_cls(::Class* cls);

  // optional .Func func = 2;
  bool has_func() const;
  void clear_func();
  static const int kFuncFieldNumber = 2;
  const ::Func& func() const;
  ::Func* mutable_func();
  ::Func* release_func();
  void set_allocated_func(::Func* func);

  // optional .VarDeclStmt var_decl = 3;
  bool has_var_decl() const;
  void clear_var_decl();
  static const int kVarDeclFieldNumber = 3;
  const ::VarDeclStmt& var_decl() const;
  ::VarDeclStmt* mutable_var_decl();
  ::VarDeclStmt* release_var_decl();
  void set_allocated_var_decl(::VarDeclStmt* var_decl);

  // optional .ExternFunc extern_func = 4;
  bool has_extern_func() const;
  void clear_extern_func();
  static const int kExternFuncFieldNumber = 4;
  const ::ExternFunc& extern_func() const;
  ::ExternFunc* mutable_extern_func();
  ::ExternFunc* release_extern_func();
  void set_allocated_extern_func(::ExternFunc* extern_func);

  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:Module.Member)
 private:
  inline void set_has_cls();
  inline void set_has_func();
  inline void set_has_var_decl();
  inline void set_has_extern_func();

  inline bool has_type() const;
  void clear_type();
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union TypeUnion {
    TypeUnion() {}
    ::Class* cls_;
    ::Func* func_;
    ::VarDeclStmt* var_decl_;
    ::ExternFunc* extern_func_;
  } type_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_ast_2eproto_impl();
  friend void  protobuf_AddDesc_ast_2eproto_impl();
  friend void protobuf_AssignDesc_ast_2eproto();
  friend void protobuf_ShutdownFile_ast_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Module_Member> Module_Member_default_instance_;

// -------------------------------------------------------------------

class Module : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Module) */ {
 public:
  Module();
  virtual ~Module();

  Module(const Module& from);

  inline Module& operator=(const Module& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Module& default_instance();

  static const Module* internal_default_instance();

  void Swap(Module* other);

  // implements Message ----------------------------------------------

  inline Module* New() const { return New(NULL); }

  Module* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Module& from);
  void MergeFrom(const Module& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Module* other);
  void UnsafeMergeFrom(const Module& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Module_Member Member;

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .Module.Member members = 2;
  int members_size() const;
  void clear_members();
  static const int kMembersFieldNumber = 2;
  const ::Module_Member& members(int index) const;
  ::Module_Member* mutable_members(int index);
  ::Module_Member* add_members();
  ::google::protobuf::RepeatedPtrField< ::Module_Member >*
      mutable_members();
  const ::google::protobuf::RepeatedPtrField< ::Module_Member >&
      members() const;

  // @@protoc_insertion_point(class_scope:Module)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Module_Member > members_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ast_2eproto_impl();
  friend void  protobuf_AddDesc_ast_2eproto_impl();
  friend void protobuf_AssignDesc_ast_2eproto();
  friend void protobuf_ShutdownFile_ast_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Module> Module_default_instance_;

// -------------------------------------------------------------------

class TypeSpec : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TypeSpec) */ {
 public:
  TypeSpec();
  virtual ~TypeSpec();

  TypeSpec(const TypeSpec& from);

  inline TypeSpec& operator=(const TypeSpec& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TypeSpec& default_instance();

  static const TypeSpec* internal_default_instance();

  void Swap(TypeSpec* other);

  // implements Message ----------------------------------------------

  inline TypeSpec* New() const { return New(NULL); }

  TypeSpec* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TypeSpec& from);
  void MergeFrom(const TypeSpec& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TypeSpec* other);
  void UnsafeMergeFrom(const TypeSpec& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .TypeSpec params = 2;
  int params_size() const;
  void clear_params();
  static const int kParamsFieldNumber = 2;
  const ::TypeSpec& params(int index) const;
  ::TypeSpec* mutable_params(int index);
  ::TypeSpec* add_params();
  ::google::protobuf::RepeatedPtrField< ::TypeSpec >*
      mutable_params();
  const ::google::protobuf::RepeatedPtrField< ::TypeSpec >&
      params() const;

  // optional .TypeSpec parent = 3;
  bool has_parent() const;
  void clear_parent();
  static const int kParentFieldNumber = 3;
  const ::TypeSpec& parent() const;
  ::TypeSpec* mutable_parent();
  ::TypeSpec* release_parent();
  void set_allocated_parent(::TypeSpec* parent);

  // @@protoc_insertion_point(class_scope:TypeSpec)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::TypeSpec > params_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::TypeSpec* parent_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ast_2eproto_impl();
  friend void  protobuf_AddDesc_ast_2eproto_impl();
  friend void protobuf_AssignDesc_ast_2eproto();
  friend void protobuf_ShutdownFile_ast_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TypeSpec> TypeSpec_default_instance_;

// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ConstantExpr

// optional string stringValue = 1;
inline bool ConstantExpr::has_stringvalue() const {
  return value_case() == kStringValue;
}
inline void ConstantExpr::set_has_stringvalue() {
  _oneof_case_[0] = kStringValue;
}
inline void ConstantExpr::clear_stringvalue() {
  if (has_stringvalue()) {
    value_.stringvalue_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_value();
  }
}
inline const ::std::string& ConstantExpr::stringvalue() const {
  // @@protoc_insertion_point(field_get:ConstantExpr.stringValue)
  if (has_stringvalue()) {
    return value_.stringvalue_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void ConstantExpr::set_stringvalue(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ConstantExpr.stringValue)
  if (!has_stringvalue()) {
    clear_value();
    set_has_stringvalue();
    value_.stringvalue_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.stringvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ConstantExpr.stringValue)
}
inline void ConstantExpr::set_stringvalue(const char* value) {
  if (!has_stringvalue()) {
    clear_value();
    set_has_stringvalue();
    value_.stringvalue_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.stringvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ConstantExpr.stringValue)
}
inline void ConstantExpr::set_stringvalue(const char* value, size_t size) {
  if (!has_stringvalue()) {
    clear_value();
    set_has_stringvalue();
    value_.stringvalue_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.stringvalue_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ConstantExpr.stringValue)
}
inline ::std::string* ConstantExpr::mutable_stringvalue() {
  if (!has_stringvalue()) {
    clear_value();
    set_has_stringvalue();
    value_.stringvalue_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:ConstantExpr.stringValue)
  return value_.stringvalue_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConstantExpr::release_stringvalue() {
  // @@protoc_insertion_point(field_release:ConstantExpr.stringValue)
  if (has_stringvalue()) {
    clear_has_value();
    return value_.stringvalue_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void ConstantExpr::set_allocated_stringvalue(::std::string* stringvalue) {
  if (!has_stringvalue()) {
    value_.stringvalue_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_value();
  if (stringvalue != NULL) {
    set_has_stringvalue();
    value_.stringvalue_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        stringvalue);
  }
  // @@protoc_insertion_point(field_set_allocated:ConstantExpr.stringValue)
}

// optional int64 intValue = 2;
inline bool ConstantExpr::has_intvalue() const {
  return value_case() == kIntValue;
}
inline void ConstantExpr::set_has_intvalue() {
  _oneof_case_[0] = kIntValue;
}
inline void ConstantExpr::clear_intvalue() {
  if (has_intvalue()) {
    value_.intvalue_ = GOOGLE_LONGLONG(0);
    clear_has_value();
  }
}
inline ::google::protobuf::int64 ConstantExpr::intvalue() const {
  // @@protoc_insertion_point(field_get:ConstantExpr.intValue)
  if (has_intvalue()) {
    return value_.intvalue_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void ConstantExpr::set_intvalue(::google::protobuf::int64 value) {
  if (!has_intvalue()) {
    clear_value();
    set_has_intvalue();
  }
  value_.intvalue_ = value;
  // @@protoc_insertion_point(field_set:ConstantExpr.intValue)
}

// optional bool boolValue = 3;
inline bool ConstantExpr::has_boolvalue() const {
  return value_case() == kBoolValue;
}
inline void ConstantExpr::set_has_boolvalue() {
  _oneof_case_[0] = kBoolValue;
}
inline void ConstantExpr::clear_boolvalue() {
  if (has_boolvalue()) {
    value_.boolvalue_ = false;
    clear_has_value();
  }
}
inline bool ConstantExpr::boolvalue() const {
  // @@protoc_insertion_point(field_get:ConstantExpr.boolValue)
  if (has_boolvalue()) {
    return value_.boolvalue_;
  }
  return false;
}
inline void ConstantExpr::set_boolvalue(bool value) {
  if (!has_boolvalue()) {
    clear_value();
    set_has_boolvalue();
  }
  value_.boolvalue_ = value;
  // @@protoc_insertion_point(field_set:ConstantExpr.boolValue)
}

inline bool ConstantExpr::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void ConstantExpr::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline ConstantExpr::ValueCase ConstantExpr::value_case() const {
  return ConstantExpr::ValueCase(_oneof_case_[0]);
}
inline const ConstantExpr* ConstantExpr::internal_default_instance() {
  return &ConstantExpr_default_instance_.get();
}
// -------------------------------------------------------------------

// VarExpr

// optional string var = 1;
inline void VarExpr::clear_var() {
  var_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VarExpr::var() const {
  // @@protoc_insertion_point(field_get:VarExpr.var)
  return var_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VarExpr::set_var(const ::std::string& value) {
  
  var_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:VarExpr.var)
}
inline void VarExpr::set_var(const char* value) {
  
  var_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:VarExpr.var)
}
inline void VarExpr::set_var(const char* value, size_t size) {
  
  var_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:VarExpr.var)
}
inline ::std::string* VarExpr::mutable_var() {
  
  // @@protoc_insertion_point(field_mutable:VarExpr.var)
  return var_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VarExpr::release_var() {
  // @@protoc_insertion_point(field_release:VarExpr.var)
  
  return var_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VarExpr::set_allocated_var(::std::string* var) {
  if (var != NULL) {
    
  } else {
    
  }
  var_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), var);
  // @@protoc_insertion_point(field_set_allocated:VarExpr.var)
}

inline const VarExpr* VarExpr::internal_default_instance() {
  return &VarExpr_default_instance_.get();
}
// -------------------------------------------------------------------

// MemberExpr

// optional .Expr expr = 1;
inline bool MemberExpr::has_expr() const {
  return this != internal_default_instance() && expr_ != NULL;
}
inline void MemberExpr::clear_expr() {
  if (GetArenaNoVirtual() == NULL && expr_ != NULL) delete expr_;
  expr_ = NULL;
}
inline const ::Expr& MemberExpr::expr() const {
  // @@protoc_insertion_point(field_get:MemberExpr.expr)
  return expr_ != NULL ? *expr_
                         : *::Expr::internal_default_instance();
}
inline ::Expr* MemberExpr::mutable_expr() {
  
  if (expr_ == NULL) {
    expr_ = new ::Expr;
  }
  // @@protoc_insertion_point(field_mutable:MemberExpr.expr)
  return expr_;
}
inline ::Expr* MemberExpr::release_expr() {
  // @@protoc_insertion_point(field_release:MemberExpr.expr)
  
  ::Expr* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline void MemberExpr::set_allocated_expr(::Expr* expr) {
  delete expr_;
  expr_ = expr;
  if (expr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:MemberExpr.expr)
}

// optional string member = 2;
inline void MemberExpr::clear_member() {
  member_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MemberExpr::member() const {
  // @@protoc_insertion_point(field_get:MemberExpr.member)
  return member_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MemberExpr::set_member(const ::std::string& value) {
  
  member_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MemberExpr.member)
}
inline void MemberExpr::set_member(const char* value) {
  
  member_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MemberExpr.member)
}
inline void MemberExpr::set_member(const char* value, size_t size) {
  
  member_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MemberExpr.member)
}
inline ::std::string* MemberExpr::mutable_member() {
  
  // @@protoc_insertion_point(field_mutable:MemberExpr.member)
  return member_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MemberExpr::release_member() {
  // @@protoc_insertion_point(field_release:MemberExpr.member)
  
  return member_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MemberExpr::set_allocated_member(::std::string* member) {
  if (member != NULL) {
    
  } else {
    
  }
  member_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), member);
  // @@protoc_insertion_point(field_set_allocated:MemberExpr.member)
}

inline const MemberExpr* MemberExpr::internal_default_instance() {
  return &MemberExpr_default_instance_.get();
}
// -------------------------------------------------------------------

// IndexExpr

// optional .Expr expr = 1;
inline bool IndexExpr::has_expr() const {
  return this != internal_default_instance() && expr_ != NULL;
}
inline void IndexExpr::clear_expr() {
  if (GetArenaNoVirtual() == NULL && expr_ != NULL) delete expr_;
  expr_ = NULL;
}
inline const ::Expr& IndexExpr::expr() const {
  // @@protoc_insertion_point(field_get:IndexExpr.expr)
  return expr_ != NULL ? *expr_
                         : *::Expr::internal_default_instance();
}
inline ::Expr* IndexExpr::mutable_expr() {
  
  if (expr_ == NULL) {
    expr_ = new ::Expr;
  }
  // @@protoc_insertion_point(field_mutable:IndexExpr.expr)
  return expr_;
}
inline ::Expr* IndexExpr::release_expr() {
  // @@protoc_insertion_point(field_release:IndexExpr.expr)
  
  ::Expr* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline void IndexExpr::set_allocated_expr(::Expr* expr) {
  delete expr_;
  expr_ = expr;
  if (expr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:IndexExpr.expr)
}

// optional .Expr index_expr = 2;
inline bool IndexExpr::has_index_expr() const {
  return this != internal_default_instance() && index_expr_ != NULL;
}
inline void IndexExpr::clear_index_expr() {
  if (GetArenaNoVirtual() == NULL && index_expr_ != NULL) delete index_expr_;
  index_expr_ = NULL;
}
inline const ::Expr& IndexExpr::index_expr() const {
  // @@protoc_insertion_point(field_get:IndexExpr.index_expr)
  return index_expr_ != NULL ? *index_expr_
                         : *::Expr::internal_default_instance();
}
inline ::Expr* IndexExpr::mutable_index_expr() {
  
  if (index_expr_ == NULL) {
    index_expr_ = new ::Expr;
  }
  // @@protoc_insertion_point(field_mutable:IndexExpr.index_expr)
  return index_expr_;
}
inline ::Expr* IndexExpr::release_index_expr() {
  // @@protoc_insertion_point(field_release:IndexExpr.index_expr)
  
  ::Expr* temp = index_expr_;
  index_expr_ = NULL;
  return temp;
}
inline void IndexExpr::set_allocated_index_expr(::Expr* index_expr) {
  delete index_expr_;
  index_expr_ = index_expr;
  if (index_expr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:IndexExpr.index_expr)
}

inline const IndexExpr* IndexExpr::internal_default_instance() {
  return &IndexExpr_default_instance_.get();
}
// -------------------------------------------------------------------

// CallExpr

// optional .Expr expr = 1;
inline bool CallExpr::has_expr() const {
  return this != internal_default_instance() && expr_ != NULL;
}
inline void CallExpr::clear_expr() {
  if (GetArenaNoVirtual() == NULL && expr_ != NULL) delete expr_;
  expr_ = NULL;
}
inline const ::Expr& CallExpr::expr() const {
  // @@protoc_insertion_point(field_get:CallExpr.expr)
  return expr_ != NULL ? *expr_
                         : *::Expr::internal_default_instance();
}
inline ::Expr* CallExpr::mutable_expr() {
  
  if (expr_ == NULL) {
    expr_ = new ::Expr;
  }
  // @@protoc_insertion_point(field_mutable:CallExpr.expr)
  return expr_;
}
inline ::Expr* CallExpr::release_expr() {
  // @@protoc_insertion_point(field_release:CallExpr.expr)
  
  ::Expr* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline void CallExpr::set_allocated_expr(::Expr* expr) {
  delete expr_;
  expr_ = expr;
  if (expr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CallExpr.expr)
}

// repeated .Expr arg_exprs = 2;
inline int CallExpr::arg_exprs_size() const {
  return arg_exprs_.size();
}
inline void CallExpr::clear_arg_exprs() {
  arg_exprs_.Clear();
}
inline const ::Expr& CallExpr::arg_exprs(int index) const {
  // @@protoc_insertion_point(field_get:CallExpr.arg_exprs)
  return arg_exprs_.Get(index);
}
inline ::Expr* CallExpr::mutable_arg_exprs(int index) {
  // @@protoc_insertion_point(field_mutable:CallExpr.arg_exprs)
  return arg_exprs_.Mutable(index);
}
inline ::Expr* CallExpr::add_arg_exprs() {
  // @@protoc_insertion_point(field_add:CallExpr.arg_exprs)
  return arg_exprs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Expr >*
CallExpr::mutable_arg_exprs() {
  // @@protoc_insertion_point(field_mutable_list:CallExpr.arg_exprs)
  return &arg_exprs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Expr >&
CallExpr::arg_exprs() const {
  // @@protoc_insertion_point(field_list:CallExpr.arg_exprs)
  return arg_exprs_;
}

inline const CallExpr* CallExpr::internal_default_instance() {
  return &CallExpr_default_instance_.get();
}
// -------------------------------------------------------------------

// UnaryOpExpr

// optional .UnaryOpExpr.Op op = 1;
inline void UnaryOpExpr::clear_op() {
  op_ = 0;
}
inline ::UnaryOpExpr_Op UnaryOpExpr::op() const {
  // @@protoc_insertion_point(field_get:UnaryOpExpr.op)
  return static_cast< ::UnaryOpExpr_Op >(op_);
}
inline void UnaryOpExpr::set_op(::UnaryOpExpr_Op value) {
  
  op_ = value;
  // @@protoc_insertion_point(field_set:UnaryOpExpr.op)
}

// optional .Expr expr = 2;
inline bool UnaryOpExpr::has_expr() const {
  return this != internal_default_instance() && expr_ != NULL;
}
inline void UnaryOpExpr::clear_expr() {
  if (GetArenaNoVirtual() == NULL && expr_ != NULL) delete expr_;
  expr_ = NULL;
}
inline const ::Expr& UnaryOpExpr::expr() const {
  // @@protoc_insertion_point(field_get:UnaryOpExpr.expr)
  return expr_ != NULL ? *expr_
                         : *::Expr::internal_default_instance();
}
inline ::Expr* UnaryOpExpr::mutable_expr() {
  
  if (expr_ == NULL) {
    expr_ = new ::Expr;
  }
  // @@protoc_insertion_point(field_mutable:UnaryOpExpr.expr)
  return expr_;
}
inline ::Expr* UnaryOpExpr::release_expr() {
  // @@protoc_insertion_point(field_release:UnaryOpExpr.expr)
  
  ::Expr* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline void UnaryOpExpr::set_allocated_expr(::Expr* expr) {
  delete expr_;
  expr_ = expr;
  if (expr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:UnaryOpExpr.expr)
}

inline const UnaryOpExpr* UnaryOpExpr::internal_default_instance() {
  return &UnaryOpExpr_default_instance_.get();
}
// -------------------------------------------------------------------

// BinaryOpExpr

// optional .BinaryOpExpr.Op op = 1;
inline void BinaryOpExpr::clear_op() {
  op_ = 0;
}
inline ::BinaryOpExpr_Op BinaryOpExpr::op() const {
  // @@protoc_insertion_point(field_get:BinaryOpExpr.op)
  return static_cast< ::BinaryOpExpr_Op >(op_);
}
inline void BinaryOpExpr::set_op(::BinaryOpExpr_Op value) {
  
  op_ = value;
  // @@protoc_insertion_point(field_set:BinaryOpExpr.op)
}

// optional .Expr left_expr = 2;
inline bool BinaryOpExpr::has_left_expr() const {
  return this != internal_default_instance() && left_expr_ != NULL;
}
inline void BinaryOpExpr::clear_left_expr() {
  if (GetArenaNoVirtual() == NULL && left_expr_ != NULL) delete left_expr_;
  left_expr_ = NULL;
}
inline const ::Expr& BinaryOpExpr::left_expr() const {
  // @@protoc_insertion_point(field_get:BinaryOpExpr.left_expr)
  return left_expr_ != NULL ? *left_expr_
                         : *::Expr::internal_default_instance();
}
inline ::Expr* BinaryOpExpr::mutable_left_expr() {
  
  if (left_expr_ == NULL) {
    left_expr_ = new ::Expr;
  }
  // @@protoc_insertion_point(field_mutable:BinaryOpExpr.left_expr)
  return left_expr_;
}
inline ::Expr* BinaryOpExpr::release_left_expr() {
  // @@protoc_insertion_point(field_release:BinaryOpExpr.left_expr)
  
  ::Expr* temp = left_expr_;
  left_expr_ = NULL;
  return temp;
}
inline void BinaryOpExpr::set_allocated_left_expr(::Expr* left_expr) {
  delete left_expr_;
  left_expr_ = left_expr;
  if (left_expr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:BinaryOpExpr.left_expr)
}

// optional .Expr right_expr = 3;
inline bool BinaryOpExpr::has_right_expr() const {
  return this != internal_default_instance() && right_expr_ != NULL;
}
inline void BinaryOpExpr::clear_right_expr() {
  if (GetArenaNoVirtual() == NULL && right_expr_ != NULL) delete right_expr_;
  right_expr_ = NULL;
}
inline const ::Expr& BinaryOpExpr::right_expr() const {
  // @@protoc_insertion_point(field_get:BinaryOpExpr.right_expr)
  return right_expr_ != NULL ? *right_expr_
                         : *::Expr::internal_default_instance();
}
inline ::Expr* BinaryOpExpr::mutable_right_expr() {
  
  if (right_expr_ == NULL) {
    right_expr_ = new ::Expr;
  }
  // @@protoc_insertion_point(field_mutable:BinaryOpExpr.right_expr)
  return right_expr_;
}
inline ::Expr* BinaryOpExpr::release_right_expr() {
  // @@protoc_insertion_point(field_release:BinaryOpExpr.right_expr)
  
  ::Expr* temp = right_expr_;
  right_expr_ = NULL;
  return temp;
}
inline void BinaryOpExpr::set_allocated_right_expr(::Expr* right_expr) {
  delete right_expr_;
  right_expr_ = right_expr;
  if (right_expr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:BinaryOpExpr.right_expr)
}

inline const BinaryOpExpr* BinaryOpExpr::internal_default_instance() {
  return &BinaryOpExpr_default_instance_.get();
}
// -------------------------------------------------------------------

// AssignExpr

// optional .Expr dest_expr = 1;
inline bool AssignExpr::has_dest_expr() const {
  return this != internal_default_instance() && dest_expr_ != NULL;
}
inline void AssignExpr::clear_dest_expr() {
  if (GetArenaNoVirtual() == NULL && dest_expr_ != NULL) delete dest_expr_;
  dest_expr_ = NULL;
}
inline const ::Expr& AssignExpr::dest_expr() const {
  // @@protoc_insertion_point(field_get:AssignExpr.dest_expr)
  return dest_expr_ != NULL ? *dest_expr_
                         : *::Expr::internal_default_instance();
}
inline ::Expr* AssignExpr::mutable_dest_expr() {
  
  if (dest_expr_ == NULL) {
    dest_expr_ = new ::Expr;
  }
  // @@protoc_insertion_point(field_mutable:AssignExpr.dest_expr)
  return dest_expr_;
}
inline ::Expr* AssignExpr::release_dest_expr() {
  // @@protoc_insertion_point(field_release:AssignExpr.dest_expr)
  
  ::Expr* temp = dest_expr_;
  dest_expr_ = NULL;
  return temp;
}
inline void AssignExpr::set_allocated_dest_expr(::Expr* dest_expr) {
  delete dest_expr_;
  dest_expr_ = dest_expr;
  if (dest_expr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:AssignExpr.dest_expr)
}

// optional .Expr value_expr = 2;
inline bool AssignExpr::has_value_expr() const {
  return this != internal_default_instance() && value_expr_ != NULL;
}
inline void AssignExpr::clear_value_expr() {
  if (GetArenaNoVirtual() == NULL && value_expr_ != NULL) delete value_expr_;
  value_expr_ = NULL;
}
inline const ::Expr& AssignExpr::value_expr() const {
  // @@protoc_insertion_point(field_get:AssignExpr.value_expr)
  return value_expr_ != NULL ? *value_expr_
                         : *::Expr::internal_default_instance();
}
inline ::Expr* AssignExpr::mutable_value_expr() {
  
  if (value_expr_ == NULL) {
    value_expr_ = new ::Expr;
  }
  // @@protoc_insertion_point(field_mutable:AssignExpr.value_expr)
  return value_expr_;
}
inline ::Expr* AssignExpr::release_value_expr() {
  // @@protoc_insertion_point(field_release:AssignExpr.value_expr)
  
  ::Expr* temp = value_expr_;
  value_expr_ = NULL;
  return temp;
}
inline void AssignExpr::set_allocated_value_expr(::Expr* value_expr) {
  delete value_expr_;
  value_expr_ = value_expr;
  if (value_expr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:AssignExpr.value_expr)
}

inline const AssignExpr* AssignExpr::internal_default_instance() {
  return &AssignExpr_default_instance_.get();
}
// -------------------------------------------------------------------

// Expr

// optional .ConstantExpr constant = 1;
inline bool Expr::has_constant() const {
  return type_case() == kConstant;
}
inline void Expr::set_has_constant() {
  _oneof_case_[0] = kConstant;
}
inline void Expr::clear_constant() {
  if (has_constant()) {
    delete type_.constant_;
    clear_has_type();
  }
}
inline  const ::ConstantExpr& Expr::constant() const {
  // @@protoc_insertion_point(field_get:Expr.constant)
  return has_constant()
      ? *type_.constant_
      : ::ConstantExpr::default_instance();
}
inline ::ConstantExpr* Expr::mutable_constant() {
  if (!has_constant()) {
    clear_type();
    set_has_constant();
    type_.constant_ = new ::ConstantExpr;
  }
  // @@protoc_insertion_point(field_mutable:Expr.constant)
  return type_.constant_;
}
inline ::ConstantExpr* Expr::release_constant() {
  // @@protoc_insertion_point(field_release:Expr.constant)
  if (has_constant()) {
    clear_has_type();
    ::ConstantExpr* temp = type_.constant_;
    type_.constant_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Expr::set_allocated_constant(::ConstantExpr* constant) {
  clear_type();
  if (constant) {
    set_has_constant();
    type_.constant_ = constant;
  }
  // @@protoc_insertion_point(field_set_allocated:Expr.constant)
}

// optional .VarExpr var = 2;
inline bool Expr::has_var() const {
  return type_case() == kVar;
}
inline void Expr::set_has_var() {
  _oneof_case_[0] = kVar;
}
inline void Expr::clear_var() {
  if (has_var()) {
    delete type_.var_;
    clear_has_type();
  }
}
inline  const ::VarExpr& Expr::var() const {
  // @@protoc_insertion_point(field_get:Expr.var)
  return has_var()
      ? *type_.var_
      : ::VarExpr::default_instance();
}
inline ::VarExpr* Expr::mutable_var() {
  if (!has_var()) {
    clear_type();
    set_has_var();
    type_.var_ = new ::VarExpr;
  }
  // @@protoc_insertion_point(field_mutable:Expr.var)
  return type_.var_;
}
inline ::VarExpr* Expr::release_var() {
  // @@protoc_insertion_point(field_release:Expr.var)
  if (has_var()) {
    clear_has_type();
    ::VarExpr* temp = type_.var_;
    type_.var_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Expr::set_allocated_var(::VarExpr* var) {
  clear_type();
  if (var) {
    set_has_var();
    type_.var_ = var;
  }
  // @@protoc_insertion_point(field_set_allocated:Expr.var)
}

// optional .MemberExpr member = 3;
inline bool Expr::has_member() const {
  return type_case() == kMember;
}
inline void Expr::set_has_member() {
  _oneof_case_[0] = kMember;
}
inline void Expr::clear_member() {
  if (has_member()) {
    delete type_.member_;
    clear_has_type();
  }
}
inline  const ::MemberExpr& Expr::member() const {
  // @@protoc_insertion_point(field_get:Expr.member)
  return has_member()
      ? *type_.member_
      : ::MemberExpr::default_instance();
}
inline ::MemberExpr* Expr::mutable_member() {
  if (!has_member()) {
    clear_type();
    set_has_member();
    type_.member_ = new ::MemberExpr;
  }
  // @@protoc_insertion_point(field_mutable:Expr.member)
  return type_.member_;
}
inline ::MemberExpr* Expr::release_member() {
  // @@protoc_insertion_point(field_release:Expr.member)
  if (has_member()) {
    clear_has_type();
    ::MemberExpr* temp = type_.member_;
    type_.member_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Expr::set_allocated_member(::MemberExpr* member) {
  clear_type();
  if (member) {
    set_has_member();
    type_.member_ = member;
  }
  // @@protoc_insertion_point(field_set_allocated:Expr.member)
}

// optional .IndexExpr index = 4;
inline bool Expr::has_index() const {
  return type_case() == kIndex;
}
inline void Expr::set_has_index() {
  _oneof_case_[0] = kIndex;
}
inline void Expr::clear_index() {
  if (has_index()) {
    delete type_.index_;
    clear_has_type();
  }
}
inline  const ::IndexExpr& Expr::index() const {
  // @@protoc_insertion_point(field_get:Expr.index)
  return has_index()
      ? *type_.index_
      : ::IndexExpr::default_instance();
}
inline ::IndexExpr* Expr::mutable_index() {
  if (!has_index()) {
    clear_type();
    set_has_index();
    type_.index_ = new ::IndexExpr;
  }
  // @@protoc_insertion_point(field_mutable:Expr.index)
  return type_.index_;
}
inline ::IndexExpr* Expr::release_index() {
  // @@protoc_insertion_point(field_release:Expr.index)
  if (has_index()) {
    clear_has_type();
    ::IndexExpr* temp = type_.index_;
    type_.index_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Expr::set_allocated_index(::IndexExpr* index) {
  clear_type();
  if (index) {
    set_has_index();
    type_.index_ = index;
  }
  // @@protoc_insertion_point(field_set_allocated:Expr.index)
}

// optional .CallExpr call = 5;
inline bool Expr::has_call() const {
  return type_case() == kCall;
}
inline void Expr::set_has_call() {
  _oneof_case_[0] = kCall;
}
inline void Expr::clear_call() {
  if (has_call()) {
    delete type_.call_;
    clear_has_type();
  }
}
inline  const ::CallExpr& Expr::call() const {
  // @@protoc_insertion_point(field_get:Expr.call)
  return has_call()
      ? *type_.call_
      : ::CallExpr::default_instance();
}
inline ::CallExpr* Expr::mutable_call() {
  if (!has_call()) {
    clear_type();
    set_has_call();
    type_.call_ = new ::CallExpr;
  }
  // @@protoc_insertion_point(field_mutable:Expr.call)
  return type_.call_;
}
inline ::CallExpr* Expr::release_call() {
  // @@protoc_insertion_point(field_release:Expr.call)
  if (has_call()) {
    clear_has_type();
    ::CallExpr* temp = type_.call_;
    type_.call_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Expr::set_allocated_call(::CallExpr* call) {
  clear_type();
  if (call) {
    set_has_call();
    type_.call_ = call;
  }
  // @@protoc_insertion_point(field_set_allocated:Expr.call)
}

// optional .UnaryOpExpr unary_op = 6;
inline bool Expr::has_unary_op() const {
  return type_case() == kUnaryOp;
}
inline void Expr::set_has_unary_op() {
  _oneof_case_[0] = kUnaryOp;
}
inline void Expr::clear_unary_op() {
  if (has_unary_op()) {
    delete type_.unary_op_;
    clear_has_type();
  }
}
inline  const ::UnaryOpExpr& Expr::unary_op() const {
  // @@protoc_insertion_point(field_get:Expr.unary_op)
  return has_unary_op()
      ? *type_.unary_op_
      : ::UnaryOpExpr::default_instance();
}
inline ::UnaryOpExpr* Expr::mutable_unary_op() {
  if (!has_unary_op()) {
    clear_type();
    set_has_unary_op();
    type_.unary_op_ = new ::UnaryOpExpr;
  }
  // @@protoc_insertion_point(field_mutable:Expr.unary_op)
  return type_.unary_op_;
}
inline ::UnaryOpExpr* Expr::release_unary_op() {
  // @@protoc_insertion_point(field_release:Expr.unary_op)
  if (has_unary_op()) {
    clear_has_type();
    ::UnaryOpExpr* temp = type_.unary_op_;
    type_.unary_op_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Expr::set_allocated_unary_op(::UnaryOpExpr* unary_op) {
  clear_type();
  if (unary_op) {
    set_has_unary_op();
    type_.unary_op_ = unary_op;
  }
  // @@protoc_insertion_point(field_set_allocated:Expr.unary_op)
}

// optional .BinaryOpExpr binary_op = 7;
inline bool Expr::has_binary_op() const {
  return type_case() == kBinaryOp;
}
inline void Expr::set_has_binary_op() {
  _oneof_case_[0] = kBinaryOp;
}
inline void Expr::clear_binary_op() {
  if (has_binary_op()) {
    delete type_.binary_op_;
    clear_has_type();
  }
}
inline  const ::BinaryOpExpr& Expr::binary_op() const {
  // @@protoc_insertion_point(field_get:Expr.binary_op)
  return has_binary_op()
      ? *type_.binary_op_
      : ::BinaryOpExpr::default_instance();
}
inline ::BinaryOpExpr* Expr::mutable_binary_op() {
  if (!has_binary_op()) {
    clear_type();
    set_has_binary_op();
    type_.binary_op_ = new ::BinaryOpExpr;
  }
  // @@protoc_insertion_point(field_mutable:Expr.binary_op)
  return type_.binary_op_;
}
inline ::BinaryOpExpr* Expr::release_binary_op() {
  // @@protoc_insertion_point(field_release:Expr.binary_op)
  if (has_binary_op()) {
    clear_has_type();
    ::BinaryOpExpr* temp = type_.binary_op_;
    type_.binary_op_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Expr::set_allocated_binary_op(::BinaryOpExpr* binary_op) {
  clear_type();
  if (binary_op) {
    set_has_binary_op();
    type_.binary_op_ = binary_op;
  }
  // @@protoc_insertion_point(field_set_allocated:Expr.binary_op)
}

// optional .AssignExpr assign = 8;
inline bool Expr::has_assign() const {
  return type_case() == kAssign;
}
inline void Expr::set_has_assign() {
  _oneof_case_[0] = kAssign;
}
inline void Expr::clear_assign() {
  if (has_assign()) {
    delete type_.assign_;
    clear_has_type();
  }
}
inline  const ::AssignExpr& Expr::assign() const {
  // @@protoc_insertion_point(field_get:Expr.assign)
  return has_assign()
      ? *type_.assign_
      : ::AssignExpr::default_instance();
}
inline ::AssignExpr* Expr::mutable_assign() {
  if (!has_assign()) {
    clear_type();
    set_has_assign();
    type_.assign_ = new ::AssignExpr;
  }
  // @@protoc_insertion_point(field_mutable:Expr.assign)
  return type_.assign_;
}
inline ::AssignExpr* Expr::release_assign() {
  // @@protoc_insertion_point(field_release:Expr.assign)
  if (has_assign()) {
    clear_has_type();
    ::AssignExpr* temp = type_.assign_;
    type_.assign_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Expr::set_allocated_assign(::AssignExpr* assign) {
  clear_type();
  if (assign) {
    set_has_assign();
    type_.assign_ = assign;
  }
  // @@protoc_insertion_point(field_set_allocated:Expr.assign)
}

inline bool Expr::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Expr::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Expr::TypeCase Expr::type_case() const {
  return Expr::TypeCase(_oneof_case_[0]);
}
inline const Expr* Expr::internal_default_instance() {
  return &Expr_default_instance_.get();
}
// -------------------------------------------------------------------

// ExprStmt

// optional .Expr expr = 1;
inline bool ExprStmt::has_expr() const {
  return this != internal_default_instance() && expr_ != NULL;
}
inline void ExprStmt::clear_expr() {
  if (GetArenaNoVirtual() == NULL && expr_ != NULL) delete expr_;
  expr_ = NULL;
}
inline const ::Expr& ExprStmt::expr() const {
  // @@protoc_insertion_point(field_get:ExprStmt.expr)
  return expr_ != NULL ? *expr_
                         : *::Expr::internal_default_instance();
}
inline ::Expr* ExprStmt::mutable_expr() {
  
  if (expr_ == NULL) {
    expr_ = new ::Expr;
  }
  // @@protoc_insertion_point(field_mutable:ExprStmt.expr)
  return expr_;
}
inline ::Expr* ExprStmt::release_expr() {
  // @@protoc_insertion_point(field_release:ExprStmt.expr)
  
  ::Expr* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline void ExprStmt::set_allocated_expr(::Expr* expr) {
  delete expr_;
  expr_ = expr;
  if (expr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ExprStmt.expr)
}

inline const ExprStmt* ExprStmt::internal_default_instance() {
  return &ExprStmt_default_instance_.get();
}
// -------------------------------------------------------------------

// RetStmt

// optional .Expr expr = 1;
inline bool RetStmt::has_expr() const {
  return this != internal_default_instance() && expr_ != NULL;
}
inline void RetStmt::clear_expr() {
  if (GetArenaNoVirtual() == NULL && expr_ != NULL) delete expr_;
  expr_ = NULL;
}
inline const ::Expr& RetStmt::expr() const {
  // @@protoc_insertion_point(field_get:RetStmt.expr)
  return expr_ != NULL ? *expr_
                         : *::Expr::internal_default_instance();
}
inline ::Expr* RetStmt::mutable_expr() {
  
  if (expr_ == NULL) {
    expr_ = new ::Expr;
  }
  // @@protoc_insertion_point(field_mutable:RetStmt.expr)
  return expr_;
}
inline ::Expr* RetStmt::release_expr() {
  // @@protoc_insertion_point(field_release:RetStmt.expr)
  
  ::Expr* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline void RetStmt::set_allocated_expr(::Expr* expr) {
  delete expr_;
  expr_ = expr;
  if (expr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:RetStmt.expr)
}

inline const RetStmt* RetStmt::internal_default_instance() {
  return &RetStmt_default_instance_.get();
}
// -------------------------------------------------------------------

// BrkStmt

inline const BrkStmt* BrkStmt::internal_default_instance() {
  return &BrkStmt_default_instance_.get();
}
// -------------------------------------------------------------------

// ContStmt

inline const ContStmt* ContStmt::internal_default_instance() {
  return &ContStmt_default_instance_.get();
}
// -------------------------------------------------------------------

// CondStmt

// optional .Expr cond_expr = 1;
inline bool CondStmt::has_cond_expr() const {
  return this != internal_default_instance() && cond_expr_ != NULL;
}
inline void CondStmt::clear_cond_expr() {
  if (GetArenaNoVirtual() == NULL && cond_expr_ != NULL) delete cond_expr_;
  cond_expr_ = NULL;
}
inline const ::Expr& CondStmt::cond_expr() const {
  // @@protoc_insertion_point(field_get:CondStmt.cond_expr)
  return cond_expr_ != NULL ? *cond_expr_
                         : *::Expr::internal_default_instance();
}
inline ::Expr* CondStmt::mutable_cond_expr() {
  
  if (cond_expr_ == NULL) {
    cond_expr_ = new ::Expr;
  }
  // @@protoc_insertion_point(field_mutable:CondStmt.cond_expr)
  return cond_expr_;
}
inline ::Expr* CondStmt::release_cond_expr() {
  // @@protoc_insertion_point(field_release:CondStmt.cond_expr)
  
  ::Expr* temp = cond_expr_;
  cond_expr_ = NULL;
  return temp;
}
inline void CondStmt::set_allocated_cond_expr(::Expr* cond_expr) {
  delete cond_expr_;
  cond_expr_ = cond_expr;
  if (cond_expr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CondStmt.cond_expr)
}

// optional .Block true_block = 2;
inline bool CondStmt::has_true_block() const {
  return this != internal_default_instance() && true_block_ != NULL;
}
inline void CondStmt::clear_true_block() {
  if (GetArenaNoVirtual() == NULL && true_block_ != NULL) delete true_block_;
  true_block_ = NULL;
}
inline const ::Block& CondStmt::true_block() const {
  // @@protoc_insertion_point(field_get:CondStmt.true_block)
  return true_block_ != NULL ? *true_block_
                         : *::Block::internal_default_instance();
}
inline ::Block* CondStmt::mutable_true_block() {
  
  if (true_block_ == NULL) {
    true_block_ = new ::Block;
  }
  // @@protoc_insertion_point(field_mutable:CondStmt.true_block)
  return true_block_;
}
inline ::Block* CondStmt::release_true_block() {
  // @@protoc_insertion_point(field_release:CondStmt.true_block)
  
  ::Block* temp = true_block_;
  true_block_ = NULL;
  return temp;
}
inline void CondStmt::set_allocated_true_block(::Block* true_block) {
  delete true_block_;
  true_block_ = true_block;
  if (true_block) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CondStmt.true_block)
}

// optional .Block false_block = 3;
inline bool CondStmt::has_false_block() const {
  return this != internal_default_instance() && false_block_ != NULL;
}
inline void CondStmt::clear_false_block() {
  if (GetArenaNoVirtual() == NULL && false_block_ != NULL) delete false_block_;
  false_block_ = NULL;
}
inline const ::Block& CondStmt::false_block() const {
  // @@protoc_insertion_point(field_get:CondStmt.false_block)
  return false_block_ != NULL ? *false_block_
                         : *::Block::internal_default_instance();
}
inline ::Block* CondStmt::mutable_false_block() {
  
  if (false_block_ == NULL) {
    false_block_ = new ::Block;
  }
  // @@protoc_insertion_point(field_mutable:CondStmt.false_block)
  return false_block_;
}
inline ::Block* CondStmt::release_false_block() {
  // @@protoc_insertion_point(field_release:CondStmt.false_block)
  
  ::Block* temp = false_block_;
  false_block_ = NULL;
  return temp;
}
inline void CondStmt::set_allocated_false_block(::Block* false_block) {
  delete false_block_;
  false_block_ = false_block;
  if (false_block) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CondStmt.false_block)
}

inline const CondStmt* CondStmt::internal_default_instance() {
  return &CondStmt_default_instance_.get();
}
// -------------------------------------------------------------------

// CondLoopStmt

// optional .Expr cond_expr = 1;
inline bool CondLoopStmt::has_cond_expr() const {
  return this != internal_default_instance() && cond_expr_ != NULL;
}
inline void CondLoopStmt::clear_cond_expr() {
  if (GetArenaNoVirtual() == NULL && cond_expr_ != NULL) delete cond_expr_;
  cond_expr_ = NULL;
}
inline const ::Expr& CondLoopStmt::cond_expr() const {
  // @@protoc_insertion_point(field_get:CondLoopStmt.cond_expr)
  return cond_expr_ != NULL ? *cond_expr_
                         : *::Expr::internal_default_instance();
}
inline ::Expr* CondLoopStmt::mutable_cond_expr() {
  
  if (cond_expr_ == NULL) {
    cond_expr_ = new ::Expr;
  }
  // @@protoc_insertion_point(field_mutable:CondLoopStmt.cond_expr)
  return cond_expr_;
}
inline ::Expr* CondLoopStmt::release_cond_expr() {
  // @@protoc_insertion_point(field_release:CondLoopStmt.cond_expr)
  
  ::Expr* temp = cond_expr_;
  cond_expr_ = NULL;
  return temp;
}
inline void CondLoopStmt::set_allocated_cond_expr(::Expr* cond_expr) {
  delete cond_expr_;
  cond_expr_ = cond_expr;
  if (cond_expr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CondLoopStmt.cond_expr)
}

// optional .Block block = 2;
inline bool CondLoopStmt::has_block() const {
  return this != internal_default_instance() && block_ != NULL;
}
inline void CondLoopStmt::clear_block() {
  if (GetArenaNoVirtual() == NULL && block_ != NULL) delete block_;
  block_ = NULL;
}
inline const ::Block& CondLoopStmt::block() const {
  // @@protoc_insertion_point(field_get:CondLoopStmt.block)
  return block_ != NULL ? *block_
                         : *::Block::internal_default_instance();
}
inline ::Block* CondLoopStmt::mutable_block() {
  
  if (block_ == NULL) {
    block_ = new ::Block;
  }
  // @@protoc_insertion_point(field_mutable:CondLoopStmt.block)
  return block_;
}
inline ::Block* CondLoopStmt::release_block() {
  // @@protoc_insertion_point(field_release:CondLoopStmt.block)
  
  ::Block* temp = block_;
  block_ = NULL;
  return temp;
}
inline void CondLoopStmt::set_allocated_block(::Block* block) {
  delete block_;
  block_ = block;
  if (block) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:CondLoopStmt.block)
}

inline const CondLoopStmt* CondLoopStmt::internal_default_instance() {
  return &CondLoopStmt_default_instance_.get();
}
// -------------------------------------------------------------------

// VarDeclStmt

// optional string name = 1;
inline void VarDeclStmt::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VarDeclStmt::name() const {
  // @@protoc_insertion_point(field_get:VarDeclStmt.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VarDeclStmt::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:VarDeclStmt.name)
}
inline void VarDeclStmt::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:VarDeclStmt.name)
}
inline void VarDeclStmt::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:VarDeclStmt.name)
}
inline ::std::string* VarDeclStmt::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:VarDeclStmt.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VarDeclStmt::release_name() {
  // @@protoc_insertion_point(field_release:VarDeclStmt.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VarDeclStmt::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:VarDeclStmt.name)
}

// optional .TypeSpec type_spec = 2;
inline bool VarDeclStmt::has_type_spec() const {
  return this != internal_default_instance() && type_spec_ != NULL;
}
inline void VarDeclStmt::clear_type_spec() {
  if (GetArenaNoVirtual() == NULL && type_spec_ != NULL) delete type_spec_;
  type_spec_ = NULL;
}
inline const ::TypeSpec& VarDeclStmt::type_spec() const {
  // @@protoc_insertion_point(field_get:VarDeclStmt.type_spec)
  return type_spec_ != NULL ? *type_spec_
                         : *::TypeSpec::internal_default_instance();
}
inline ::TypeSpec* VarDeclStmt::mutable_type_spec() {
  
  if (type_spec_ == NULL) {
    type_spec_ = new ::TypeSpec;
  }
  // @@protoc_insertion_point(field_mutable:VarDeclStmt.type_spec)
  return type_spec_;
}
inline ::TypeSpec* VarDeclStmt::release_type_spec() {
  // @@protoc_insertion_point(field_release:VarDeclStmt.type_spec)
  
  ::TypeSpec* temp = type_spec_;
  type_spec_ = NULL;
  return temp;
}
inline void VarDeclStmt::set_allocated_type_spec(::TypeSpec* type_spec) {
  delete type_spec_;
  type_spec_ = type_spec;
  if (type_spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:VarDeclStmt.type_spec)
}

// optional .VarDeclStmt.Mode mode = 3;
inline void VarDeclStmt::clear_mode() {
  mode_ = 0;
}
inline ::VarDeclStmt_Mode VarDeclStmt::mode() const {
  // @@protoc_insertion_point(field_get:VarDeclStmt.mode)
  return static_cast< ::VarDeclStmt_Mode >(mode_);
}
inline void VarDeclStmt::set_mode(::VarDeclStmt_Mode value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:VarDeclStmt.mode)
}

// optional .Expr init_expr = 4;
inline bool VarDeclStmt::has_init_expr() const {
  return this != internal_default_instance() && init_expr_ != NULL;
}
inline void VarDeclStmt::clear_init_expr() {
  if (GetArenaNoVirtual() == NULL && init_expr_ != NULL) delete init_expr_;
  init_expr_ = NULL;
}
inline const ::Expr& VarDeclStmt::init_expr() const {
  // @@protoc_insertion_point(field_get:VarDeclStmt.init_expr)
  return init_expr_ != NULL ? *init_expr_
                         : *::Expr::internal_default_instance();
}
inline ::Expr* VarDeclStmt::mutable_init_expr() {
  
  if (init_expr_ == NULL) {
    init_expr_ = new ::Expr;
  }
  // @@protoc_insertion_point(field_mutable:VarDeclStmt.init_expr)
  return init_expr_;
}
inline ::Expr* VarDeclStmt::release_init_expr() {
  // @@protoc_insertion_point(field_release:VarDeclStmt.init_expr)
  
  ::Expr* temp = init_expr_;
  init_expr_ = NULL;
  return temp;
}
inline void VarDeclStmt::set_allocated_init_expr(::Expr* init_expr) {
  delete init_expr_;
  init_expr_ = init_expr;
  if (init_expr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:VarDeclStmt.init_expr)
}

inline const VarDeclStmt* VarDeclStmt::internal_default_instance() {
  return &VarDeclStmt_default_instance_.get();
}
// -------------------------------------------------------------------

// Stmt

// optional .ExprStmt expr = 1;
inline bool Stmt::has_expr() const {
  return type_case() == kExpr;
}
inline void Stmt::set_has_expr() {
  _oneof_case_[0] = kExpr;
}
inline void Stmt::clear_expr() {
  if (has_expr()) {
    delete type_.expr_;
    clear_has_type();
  }
}
inline  const ::ExprStmt& Stmt::expr() const {
  // @@protoc_insertion_point(field_get:Stmt.expr)
  return has_expr()
      ? *type_.expr_
      : ::ExprStmt::default_instance();
}
inline ::ExprStmt* Stmt::mutable_expr() {
  if (!has_expr()) {
    clear_type();
    set_has_expr();
    type_.expr_ = new ::ExprStmt;
  }
  // @@protoc_insertion_point(field_mutable:Stmt.expr)
  return type_.expr_;
}
inline ::ExprStmt* Stmt::release_expr() {
  // @@protoc_insertion_point(field_release:Stmt.expr)
  if (has_expr()) {
    clear_has_type();
    ::ExprStmt* temp = type_.expr_;
    type_.expr_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Stmt::set_allocated_expr(::ExprStmt* expr) {
  clear_type();
  if (expr) {
    set_has_expr();
    type_.expr_ = expr;
  }
  // @@protoc_insertion_point(field_set_allocated:Stmt.expr)
}

// optional .RetStmt ret = 2;
inline bool Stmt::has_ret() const {
  return type_case() == kRet;
}
inline void Stmt::set_has_ret() {
  _oneof_case_[0] = kRet;
}
inline void Stmt::clear_ret() {
  if (has_ret()) {
    delete type_.ret_;
    clear_has_type();
  }
}
inline  const ::RetStmt& Stmt::ret() const {
  // @@protoc_insertion_point(field_get:Stmt.ret)
  return has_ret()
      ? *type_.ret_
      : ::RetStmt::default_instance();
}
inline ::RetStmt* Stmt::mutable_ret() {
  if (!has_ret()) {
    clear_type();
    set_has_ret();
    type_.ret_ = new ::RetStmt;
  }
  // @@protoc_insertion_point(field_mutable:Stmt.ret)
  return type_.ret_;
}
inline ::RetStmt* Stmt::release_ret() {
  // @@protoc_insertion_point(field_release:Stmt.ret)
  if (has_ret()) {
    clear_has_type();
    ::RetStmt* temp = type_.ret_;
    type_.ret_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Stmt::set_allocated_ret(::RetStmt* ret) {
  clear_type();
  if (ret) {
    set_has_ret();
    type_.ret_ = ret;
  }
  // @@protoc_insertion_point(field_set_allocated:Stmt.ret)
}

// optional .BrkStmt brk = 3;
inline bool Stmt::has_brk() const {
  return type_case() == kBrk;
}
inline void Stmt::set_has_brk() {
  _oneof_case_[0] = kBrk;
}
inline void Stmt::clear_brk() {
  if (has_brk()) {
    delete type_.brk_;
    clear_has_type();
  }
}
inline  const ::BrkStmt& Stmt::brk() const {
  // @@protoc_insertion_point(field_get:Stmt.brk)
  return has_brk()
      ? *type_.brk_
      : ::BrkStmt::default_instance();
}
inline ::BrkStmt* Stmt::mutable_brk() {
  if (!has_brk()) {
    clear_type();
    set_has_brk();
    type_.brk_ = new ::BrkStmt;
  }
  // @@protoc_insertion_point(field_mutable:Stmt.brk)
  return type_.brk_;
}
inline ::BrkStmt* Stmt::release_brk() {
  // @@protoc_insertion_point(field_release:Stmt.brk)
  if (has_brk()) {
    clear_has_type();
    ::BrkStmt* temp = type_.brk_;
    type_.brk_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Stmt::set_allocated_brk(::BrkStmt* brk) {
  clear_type();
  if (brk) {
    set_has_brk();
    type_.brk_ = brk;
  }
  // @@protoc_insertion_point(field_set_allocated:Stmt.brk)
}

// optional .ContStmt cont = 4;
inline bool Stmt::has_cont() const {
  return type_case() == kCont;
}
inline void Stmt::set_has_cont() {
  _oneof_case_[0] = kCont;
}
inline void Stmt::clear_cont() {
  if (has_cont()) {
    delete type_.cont_;
    clear_has_type();
  }
}
inline  const ::ContStmt& Stmt::cont() const {
  // @@protoc_insertion_point(field_get:Stmt.cont)
  return has_cont()
      ? *type_.cont_
      : ::ContStmt::default_instance();
}
inline ::ContStmt* Stmt::mutable_cont() {
  if (!has_cont()) {
    clear_type();
    set_has_cont();
    type_.cont_ = new ::ContStmt;
  }
  // @@protoc_insertion_point(field_mutable:Stmt.cont)
  return type_.cont_;
}
inline ::ContStmt* Stmt::release_cont() {
  // @@protoc_insertion_point(field_release:Stmt.cont)
  if (has_cont()) {
    clear_has_type();
    ::ContStmt* temp = type_.cont_;
    type_.cont_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Stmt::set_allocated_cont(::ContStmt* cont) {
  clear_type();
  if (cont) {
    set_has_cont();
    type_.cont_ = cont;
  }
  // @@protoc_insertion_point(field_set_allocated:Stmt.cont)
}

// optional .CondStmt cond = 5;
inline bool Stmt::has_cond() const {
  return type_case() == kCond;
}
inline void Stmt::set_has_cond() {
  _oneof_case_[0] = kCond;
}
inline void Stmt::clear_cond() {
  if (has_cond()) {
    delete type_.cond_;
    clear_has_type();
  }
}
inline  const ::CondStmt& Stmt::cond() const {
  // @@protoc_insertion_point(field_get:Stmt.cond)
  return has_cond()
      ? *type_.cond_
      : ::CondStmt::default_instance();
}
inline ::CondStmt* Stmt::mutable_cond() {
  if (!has_cond()) {
    clear_type();
    set_has_cond();
    type_.cond_ = new ::CondStmt;
  }
  // @@protoc_insertion_point(field_mutable:Stmt.cond)
  return type_.cond_;
}
inline ::CondStmt* Stmt::release_cond() {
  // @@protoc_insertion_point(field_release:Stmt.cond)
  if (has_cond()) {
    clear_has_type();
    ::CondStmt* temp = type_.cond_;
    type_.cond_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Stmt::set_allocated_cond(::CondStmt* cond) {
  clear_type();
  if (cond) {
    set_has_cond();
    type_.cond_ = cond;
  }
  // @@protoc_insertion_point(field_set_allocated:Stmt.cond)
}

// optional .CondLoopStmt cond_loop = 6;
inline bool Stmt::has_cond_loop() const {
  return type_case() == kCondLoop;
}
inline void Stmt::set_has_cond_loop() {
  _oneof_case_[0] = kCondLoop;
}
inline void Stmt::clear_cond_loop() {
  if (has_cond_loop()) {
    delete type_.cond_loop_;
    clear_has_type();
  }
}
inline  const ::CondLoopStmt& Stmt::cond_loop() const {
  // @@protoc_insertion_point(field_get:Stmt.cond_loop)
  return has_cond_loop()
      ? *type_.cond_loop_
      : ::CondLoopStmt::default_instance();
}
inline ::CondLoopStmt* Stmt::mutable_cond_loop() {
  if (!has_cond_loop()) {
    clear_type();
    set_has_cond_loop();
    type_.cond_loop_ = new ::CondLoopStmt;
  }
  // @@protoc_insertion_point(field_mutable:Stmt.cond_loop)
  return type_.cond_loop_;
}
inline ::CondLoopStmt* Stmt::release_cond_loop() {
  // @@protoc_insertion_point(field_release:Stmt.cond_loop)
  if (has_cond_loop()) {
    clear_has_type();
    ::CondLoopStmt* temp = type_.cond_loop_;
    type_.cond_loop_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Stmt::set_allocated_cond_loop(::CondLoopStmt* cond_loop) {
  clear_type();
  if (cond_loop) {
    set_has_cond_loop();
    type_.cond_loop_ = cond_loop;
  }
  // @@protoc_insertion_point(field_set_allocated:Stmt.cond_loop)
}

// optional .VarDeclStmt var_decl = 7;
inline bool Stmt::has_var_decl() const {
  return type_case() == kVarDecl;
}
inline void Stmt::set_has_var_decl() {
  _oneof_case_[0] = kVarDecl;
}
inline void Stmt::clear_var_decl() {
  if (has_var_decl()) {
    delete type_.var_decl_;
    clear_has_type();
  }
}
inline  const ::VarDeclStmt& Stmt::var_decl() const {
  // @@protoc_insertion_point(field_get:Stmt.var_decl)
  return has_var_decl()
      ? *type_.var_decl_
      : ::VarDeclStmt::default_instance();
}
inline ::VarDeclStmt* Stmt::mutable_var_decl() {
  if (!has_var_decl()) {
    clear_type();
    set_has_var_decl();
    type_.var_decl_ = new ::VarDeclStmt;
  }
  // @@protoc_insertion_point(field_mutable:Stmt.var_decl)
  return type_.var_decl_;
}
inline ::VarDeclStmt* Stmt::release_var_decl() {
  // @@protoc_insertion_point(field_release:Stmt.var_decl)
  if (has_var_decl()) {
    clear_has_type();
    ::VarDeclStmt* temp = type_.var_decl_;
    type_.var_decl_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Stmt::set_allocated_var_decl(::VarDeclStmt* var_decl) {
  clear_type();
  if (var_decl) {
    set_has_var_decl();
    type_.var_decl_ = var_decl;
  }
  // @@protoc_insertion_point(field_set_allocated:Stmt.var_decl)
}

inline bool Stmt::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Stmt::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Stmt::TypeCase Stmt::type_case() const {
  return Stmt::TypeCase(_oneof_case_[0]);
}
inline const Stmt* Stmt::internal_default_instance() {
  return &Stmt_default_instance_.get();
}
// -------------------------------------------------------------------

// Block

// repeated .Stmt stmts = 1;
inline int Block::stmts_size() const {
  return stmts_.size();
}
inline void Block::clear_stmts() {
  stmts_.Clear();
}
inline const ::Stmt& Block::stmts(int index) const {
  // @@protoc_insertion_point(field_get:Block.stmts)
  return stmts_.Get(index);
}
inline ::Stmt* Block::mutable_stmts(int index) {
  // @@protoc_insertion_point(field_mutable:Block.stmts)
  return stmts_.Mutable(index);
}
inline ::Stmt* Block::add_stmts() {
  // @@protoc_insertion_point(field_add:Block.stmts)
  return stmts_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Stmt >*
Block::mutable_stmts() {
  // @@protoc_insertion_point(field_mutable_list:Block.stmts)
  return &stmts_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Stmt >&
Block::stmts() const {
  // @@protoc_insertion_point(field_list:Block.stmts)
  return stmts_;
}

inline const Block* Block::internal_default_instance() {
  return &Block_default_instance_.get();
}
// -------------------------------------------------------------------

// FuncParam

// optional string name = 1;
inline void FuncParam::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FuncParam::name() const {
  // @@protoc_insertion_point(field_get:FuncParam.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FuncParam::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FuncParam.name)
}
inline void FuncParam::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FuncParam.name)
}
inline void FuncParam::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FuncParam.name)
}
inline ::std::string* FuncParam::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:FuncParam.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FuncParam::release_name() {
  // @@protoc_insertion_point(field_release:FuncParam.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FuncParam::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:FuncParam.name)
}

// optional .FuncParam.Mode mode = 2;
inline void FuncParam::clear_mode() {
  mode_ = 0;
}
inline ::FuncParam_Mode FuncParam::mode() const {
  // @@protoc_insertion_point(field_get:FuncParam.mode)
  return static_cast< ::FuncParam_Mode >(mode_);
}
inline void FuncParam::set_mode(::FuncParam_Mode value) {
  
  mode_ = value;
  // @@protoc_insertion_point(field_set:FuncParam.mode)
}

// optional .TypeSpec type_spec = 3;
inline bool FuncParam::has_type_spec() const {
  return this != internal_default_instance() && type_spec_ != NULL;
}
inline void FuncParam::clear_type_spec() {
  if (GetArenaNoVirtual() == NULL && type_spec_ != NULL) delete type_spec_;
  type_spec_ = NULL;
}
inline const ::TypeSpec& FuncParam::type_spec() const {
  // @@protoc_insertion_point(field_get:FuncParam.type_spec)
  return type_spec_ != NULL ? *type_spec_
                         : *::TypeSpec::internal_default_instance();
}
inline ::TypeSpec* FuncParam::mutable_type_spec() {
  
  if (type_spec_ == NULL) {
    type_spec_ = new ::TypeSpec;
  }
  // @@protoc_insertion_point(field_mutable:FuncParam.type_spec)
  return type_spec_;
}
inline ::TypeSpec* FuncParam::release_type_spec() {
  // @@protoc_insertion_point(field_release:FuncParam.type_spec)
  
  ::TypeSpec* temp = type_spec_;
  type_spec_ = NULL;
  return temp;
}
inline void FuncParam::set_allocated_type_spec(::TypeSpec* type_spec) {
  delete type_spec_;
  type_spec_ = type_spec;
  if (type_spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:FuncParam.type_spec)
}

// optional .Expr init_expr = 4;
inline bool FuncParam::has_init_expr() const {
  return this != internal_default_instance() && init_expr_ != NULL;
}
inline void FuncParam::clear_init_expr() {
  if (GetArenaNoVirtual() == NULL && init_expr_ != NULL) delete init_expr_;
  init_expr_ = NULL;
}
inline const ::Expr& FuncParam::init_expr() const {
  // @@protoc_insertion_point(field_get:FuncParam.init_expr)
  return init_expr_ != NULL ? *init_expr_
                         : *::Expr::internal_default_instance();
}
inline ::Expr* FuncParam::mutable_init_expr() {
  
  if (init_expr_ == NULL) {
    init_expr_ = new ::Expr;
  }
  // @@protoc_insertion_point(field_mutable:FuncParam.init_expr)
  return init_expr_;
}
inline ::Expr* FuncParam::release_init_expr() {
  // @@protoc_insertion_point(field_release:FuncParam.init_expr)
  
  ::Expr* temp = init_expr_;
  init_expr_ = NULL;
  return temp;
}
inline void FuncParam::set_allocated_init_expr(::Expr* init_expr) {
  delete init_expr_;
  init_expr_ = init_expr;
  if (init_expr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:FuncParam.init_expr)
}

inline const FuncParam* FuncParam::internal_default_instance() {
  return &FuncParam_default_instance_.get();
}
// -------------------------------------------------------------------

// Func

// optional string name = 1;
inline void Func::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Func::name() const {
  // @@protoc_insertion_point(field_get:Func.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Func::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Func.name)
}
inline void Func::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Func.name)
}
inline void Func::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Func.name)
}
inline ::std::string* Func::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Func.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Func::release_name() {
  // @@protoc_insertion_point(field_release:Func.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Func::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Func.name)
}

// repeated string type_params = 2;
inline int Func::type_params_size() const {
  return type_params_.size();
}
inline void Func::clear_type_params() {
  type_params_.Clear();
}
inline const ::std::string& Func::type_params(int index) const {
  // @@protoc_insertion_point(field_get:Func.type_params)
  return type_params_.Get(index);
}
inline ::std::string* Func::mutable_type_params(int index) {
  // @@protoc_insertion_point(field_mutable:Func.type_params)
  return type_params_.Mutable(index);
}
inline void Func::set_type_params(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Func.type_params)
  type_params_.Mutable(index)->assign(value);
}
inline void Func::set_type_params(int index, const char* value) {
  type_params_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Func.type_params)
}
inline void Func::set_type_params(int index, const char* value, size_t size) {
  type_params_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Func.type_params)
}
inline ::std::string* Func::add_type_params() {
  // @@protoc_insertion_point(field_add_mutable:Func.type_params)
  return type_params_.Add();
}
inline void Func::add_type_params(const ::std::string& value) {
  type_params_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Func.type_params)
}
inline void Func::add_type_params(const char* value) {
  type_params_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Func.type_params)
}
inline void Func::add_type_params(const char* value, size_t size) {
  type_params_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Func.type_params)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Func::type_params() const {
  // @@protoc_insertion_point(field_list:Func.type_params)
  return type_params_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Func::mutable_type_params() {
  // @@protoc_insertion_point(field_mutable_list:Func.type_params)
  return &type_params_;
}

// optional .FuncParam params = 3;
inline bool Func::has_params() const {
  return this != internal_default_instance() && params_ != NULL;
}
inline void Func::clear_params() {
  if (GetArenaNoVirtual() == NULL && params_ != NULL) delete params_;
  params_ = NULL;
}
inline const ::FuncParam& Func::params() const {
  // @@protoc_insertion_point(field_get:Func.params)
  return params_ != NULL ? *params_
                         : *::FuncParam::internal_default_instance();
}
inline ::FuncParam* Func::mutable_params() {
  
  if (params_ == NULL) {
    params_ = new ::FuncParam;
  }
  // @@protoc_insertion_point(field_mutable:Func.params)
  return params_;
}
inline ::FuncParam* Func::release_params() {
  // @@protoc_insertion_point(field_release:Func.params)
  
  ::FuncParam* temp = params_;
  params_ = NULL;
  return temp;
}
inline void Func::set_allocated_params(::FuncParam* params) {
  delete params_;
  params_ = params;
  if (params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Func.params)
}

// optional .TypeSpec return_type_spec = 4;
inline bool Func::has_return_type_spec() const {
  return this != internal_default_instance() && return_type_spec_ != NULL;
}
inline void Func::clear_return_type_spec() {
  if (GetArenaNoVirtual() == NULL && return_type_spec_ != NULL) delete return_type_spec_;
  return_type_spec_ = NULL;
}
inline const ::TypeSpec& Func::return_type_spec() const {
  // @@protoc_insertion_point(field_get:Func.return_type_spec)
  return return_type_spec_ != NULL ? *return_type_spec_
                         : *::TypeSpec::internal_default_instance();
}
inline ::TypeSpec* Func::mutable_return_type_spec() {
  
  if (return_type_spec_ == NULL) {
    return_type_spec_ = new ::TypeSpec;
  }
  // @@protoc_insertion_point(field_mutable:Func.return_type_spec)
  return return_type_spec_;
}
inline ::TypeSpec* Func::release_return_type_spec() {
  // @@protoc_insertion_point(field_release:Func.return_type_spec)
  
  ::TypeSpec* temp = return_type_spec_;
  return_type_spec_ = NULL;
  return temp;
}
inline void Func::set_allocated_return_type_spec(::TypeSpec* return_type_spec) {
  delete return_type_spec_;
  return_type_spec_ = return_type_spec;
  if (return_type_spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Func.return_type_spec)
}

// optional .Func.ReturnMode return_mode = 5;
inline void Func::clear_return_mode() {
  return_mode_ = 0;
}
inline ::Func_ReturnMode Func::return_mode() const {
  // @@protoc_insertion_point(field_get:Func.return_mode)
  return static_cast< ::Func_ReturnMode >(return_mode_);
}
inline void Func::set_return_mode(::Func_ReturnMode value) {
  
  return_mode_ = value;
  // @@protoc_insertion_point(field_set:Func.return_mode)
}

// optional .Func.CC cc = 6;
inline void Func::clear_cc() {
  cc_ = 0;
}
inline ::Func_CC Func::cc() const {
  // @@protoc_insertion_point(field_get:Func.cc)
  return static_cast< ::Func_CC >(cc_);
}
inline void Func::set_cc(::Func_CC value) {
  
  cc_ = value;
  // @@protoc_insertion_point(field_set:Func.cc)
}

// optional .Block block = 7;
inline bool Func::has_block() const {
  return this != internal_default_instance() && block_ != NULL;
}
inline void Func::clear_block() {
  if (GetArenaNoVirtual() == NULL && block_ != NULL) delete block_;
  block_ = NULL;
}
inline const ::Block& Func::block() const {
  // @@protoc_insertion_point(field_get:Func.block)
  return block_ != NULL ? *block_
                         : *::Block::internal_default_instance();
}
inline ::Block* Func::mutable_block() {
  
  if (block_ == NULL) {
    block_ = new ::Block;
  }
  // @@protoc_insertion_point(field_mutable:Func.block)
  return block_;
}
inline ::Block* Func::release_block() {
  // @@protoc_insertion_point(field_release:Func.block)
  
  ::Block* temp = block_;
  block_ = NULL;
  return temp;
}
inline void Func::set_allocated_block(::Block* block) {
  delete block_;
  block_ = block;
  if (block) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Func.block)
}

inline const Func* Func::internal_default_instance() {
  return &Func_default_instance_.get();
}
// -------------------------------------------------------------------

// ExternFunc

// optional string name = 1;
inline void ExternFunc::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ExternFunc::name() const {
  // @@protoc_insertion_point(field_get:ExternFunc.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExternFunc::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ExternFunc.name)
}
inline void ExternFunc::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ExternFunc.name)
}
inline void ExternFunc::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ExternFunc.name)
}
inline ::std::string* ExternFunc::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:ExternFunc.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExternFunc::release_name() {
  // @@protoc_insertion_point(field_release:ExternFunc.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExternFunc::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ExternFunc.name)
}

// repeated .FuncParam params = 2;
inline int ExternFunc::params_size() const {
  return params_.size();
}
inline void ExternFunc::clear_params() {
  params_.Clear();
}
inline const ::FuncParam& ExternFunc::params(int index) const {
  // @@protoc_insertion_point(field_get:ExternFunc.params)
  return params_.Get(index);
}
inline ::FuncParam* ExternFunc::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:ExternFunc.params)
  return params_.Mutable(index);
}
inline ::FuncParam* ExternFunc::add_params() {
  // @@protoc_insertion_point(field_add:ExternFunc.params)
  return params_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::FuncParam >*
ExternFunc::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:ExternFunc.params)
  return &params_;
}
inline const ::google::protobuf::RepeatedPtrField< ::FuncParam >&
ExternFunc::params() const {
  // @@protoc_insertion_point(field_list:ExternFunc.params)
  return params_;
}

// optional .TypeSpec return_type_spec = 3;
inline bool ExternFunc::has_return_type_spec() const {
  return this != internal_default_instance() && return_type_spec_ != NULL;
}
inline void ExternFunc::clear_return_type_spec() {
  if (GetArenaNoVirtual() == NULL && return_type_spec_ != NULL) delete return_type_spec_;
  return_type_spec_ = NULL;
}
inline const ::TypeSpec& ExternFunc::return_type_spec() const {
  // @@protoc_insertion_point(field_get:ExternFunc.return_type_spec)
  return return_type_spec_ != NULL ? *return_type_spec_
                         : *::TypeSpec::internal_default_instance();
}
inline ::TypeSpec* ExternFunc::mutable_return_type_spec() {
  
  if (return_type_spec_ == NULL) {
    return_type_spec_ = new ::TypeSpec;
  }
  // @@protoc_insertion_point(field_mutable:ExternFunc.return_type_spec)
  return return_type_spec_;
}
inline ::TypeSpec* ExternFunc::release_return_type_spec() {
  // @@protoc_insertion_point(field_release:ExternFunc.return_type_spec)
  
  ::TypeSpec* temp = return_type_spec_;
  return_type_spec_ = NULL;
  return temp;
}
inline void ExternFunc::set_allocated_return_type_spec(::TypeSpec* return_type_spec) {
  delete return_type_spec_;
  return_type_spec_ = return_type_spec;
  if (return_type_spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:ExternFunc.return_type_spec)
}

inline const ExternFunc* ExternFunc::internal_default_instance() {
  return &ExternFunc_default_instance_.get();
}
// -------------------------------------------------------------------

// Class_Member

// optional .Class cls = 1;
inline bool Class_Member::has_cls() const {
  return type_case() == kCls;
}
inline void Class_Member::set_has_cls() {
  _oneof_case_[0] = kCls;
}
inline void Class_Member::clear_cls() {
  if (has_cls()) {
    delete type_.cls_;
    clear_has_type();
  }
}
inline  const ::Class& Class_Member::cls() const {
  // @@protoc_insertion_point(field_get:Class.Member.cls)
  return has_cls()
      ? *type_.cls_
      : ::Class::default_instance();
}
inline ::Class* Class_Member::mutable_cls() {
  if (!has_cls()) {
    clear_type();
    set_has_cls();
    type_.cls_ = new ::Class;
  }
  // @@protoc_insertion_point(field_mutable:Class.Member.cls)
  return type_.cls_;
}
inline ::Class* Class_Member::release_cls() {
  // @@protoc_insertion_point(field_release:Class.Member.cls)
  if (has_cls()) {
    clear_has_type();
    ::Class* temp = type_.cls_;
    type_.cls_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Class_Member::set_allocated_cls(::Class* cls) {
  clear_type();
  if (cls) {
    set_has_cls();
    type_.cls_ = cls;
  }
  // @@protoc_insertion_point(field_set_allocated:Class.Member.cls)
}

// optional .Func func = 2;
inline bool Class_Member::has_func() const {
  return type_case() == kFunc;
}
inline void Class_Member::set_has_func() {
  _oneof_case_[0] = kFunc;
}
inline void Class_Member::clear_func() {
  if (has_func()) {
    delete type_.func_;
    clear_has_type();
  }
}
inline  const ::Func& Class_Member::func() const {
  // @@protoc_insertion_point(field_get:Class.Member.func)
  return has_func()
      ? *type_.func_
      : ::Func::default_instance();
}
inline ::Func* Class_Member::mutable_func() {
  if (!has_func()) {
    clear_type();
    set_has_func();
    type_.func_ = new ::Func;
  }
  // @@protoc_insertion_point(field_mutable:Class.Member.func)
  return type_.func_;
}
inline ::Func* Class_Member::release_func() {
  // @@protoc_insertion_point(field_release:Class.Member.func)
  if (has_func()) {
    clear_has_type();
    ::Func* temp = type_.func_;
    type_.func_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Class_Member::set_allocated_func(::Func* func) {
  clear_type();
  if (func) {
    set_has_func();
    type_.func_ = func;
  }
  // @@protoc_insertion_point(field_set_allocated:Class.Member.func)
}

// optional .VarDeclStmt var_decl = 3;
inline bool Class_Member::has_var_decl() const {
  return type_case() == kVarDecl;
}
inline void Class_Member::set_has_var_decl() {
  _oneof_case_[0] = kVarDecl;
}
inline void Class_Member::clear_var_decl() {
  if (has_var_decl()) {
    delete type_.var_decl_;
    clear_has_type();
  }
}
inline  const ::VarDeclStmt& Class_Member::var_decl() const {
  // @@protoc_insertion_point(field_get:Class.Member.var_decl)
  return has_var_decl()
      ? *type_.var_decl_
      : ::VarDeclStmt::default_instance();
}
inline ::VarDeclStmt* Class_Member::mutable_var_decl() {
  if (!has_var_decl()) {
    clear_type();
    set_has_var_decl();
    type_.var_decl_ = new ::VarDeclStmt;
  }
  // @@protoc_insertion_point(field_mutable:Class.Member.var_decl)
  return type_.var_decl_;
}
inline ::VarDeclStmt* Class_Member::release_var_decl() {
  // @@protoc_insertion_point(field_release:Class.Member.var_decl)
  if (has_var_decl()) {
    clear_has_type();
    ::VarDeclStmt* temp = type_.var_decl_;
    type_.var_decl_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Class_Member::set_allocated_var_decl(::VarDeclStmt* var_decl) {
  clear_type();
  if (var_decl) {
    set_has_var_decl();
    type_.var_decl_ = var_decl;
  }
  // @@protoc_insertion_point(field_set_allocated:Class.Member.var_decl)
}

inline bool Class_Member::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Class_Member::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Class_Member::TypeCase Class_Member::type_case() const {
  return Class_Member::TypeCase(_oneof_case_[0]);
}
inline const Class_Member* Class_Member::internal_default_instance() {
  return &Class_Member_default_instance_.get();
}
// -------------------------------------------------------------------

// Class

// optional string name = 1;
inline void Class::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Class::name() const {
  // @@protoc_insertion_point(field_get:Class.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Class::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Class.name)
}
inline void Class::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Class.name)
}
inline void Class::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Class.name)
}
inline ::std::string* Class::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Class.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Class::release_name() {
  // @@protoc_insertion_point(field_release:Class.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Class::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Class.name)
}

// repeated string type_params = 2;
inline int Class::type_params_size() const {
  return type_params_.size();
}
inline void Class::clear_type_params() {
  type_params_.Clear();
}
inline const ::std::string& Class::type_params(int index) const {
  // @@protoc_insertion_point(field_get:Class.type_params)
  return type_params_.Get(index);
}
inline ::std::string* Class::mutable_type_params(int index) {
  // @@protoc_insertion_point(field_mutable:Class.type_params)
  return type_params_.Mutable(index);
}
inline void Class::set_type_params(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Class.type_params)
  type_params_.Mutable(index)->assign(value);
}
inline void Class::set_type_params(int index, const char* value) {
  type_params_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Class.type_params)
}
inline void Class::set_type_params(int index, const char* value, size_t size) {
  type_params_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Class.type_params)
}
inline ::std::string* Class::add_type_params() {
  // @@protoc_insertion_point(field_add_mutable:Class.type_params)
  return type_params_.Add();
}
inline void Class::add_type_params(const ::std::string& value) {
  type_params_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Class.type_params)
}
inline void Class::add_type_params(const char* value) {
  type_params_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Class.type_params)
}
inline void Class::add_type_params(const char* value, size_t size) {
  type_params_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Class.type_params)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Class::type_params() const {
  // @@protoc_insertion_point(field_list:Class.type_params)
  return type_params_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Class::mutable_type_params() {
  // @@protoc_insertion_point(field_mutable_list:Class.type_params)
  return &type_params_;
}

// repeated string super_classes = 3;
inline int Class::super_classes_size() const {
  return super_classes_.size();
}
inline void Class::clear_super_classes() {
  super_classes_.Clear();
}
inline const ::std::string& Class::super_classes(int index) const {
  // @@protoc_insertion_point(field_get:Class.super_classes)
  return super_classes_.Get(index);
}
inline ::std::string* Class::mutable_super_classes(int index) {
  // @@protoc_insertion_point(field_mutable:Class.super_classes)
  return super_classes_.Mutable(index);
}
inline void Class::set_super_classes(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Class.super_classes)
  super_classes_.Mutable(index)->assign(value);
}
inline void Class::set_super_classes(int index, const char* value) {
  super_classes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Class.super_classes)
}
inline void Class::set_super_classes(int index, const char* value, size_t size) {
  super_classes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Class.super_classes)
}
inline ::std::string* Class::add_super_classes() {
  // @@protoc_insertion_point(field_add_mutable:Class.super_classes)
  return super_classes_.Add();
}
inline void Class::add_super_classes(const ::std::string& value) {
  super_classes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Class.super_classes)
}
inline void Class::add_super_classes(const char* value) {
  super_classes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Class.super_classes)
}
inline void Class::add_super_classes(const char* value, size_t size) {
  super_classes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Class.super_classes)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Class::super_classes() const {
  // @@protoc_insertion_point(field_list:Class.super_classes)
  return super_classes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Class::mutable_super_classes() {
  // @@protoc_insertion_point(field_mutable_list:Class.super_classes)
  return &super_classes_;
}

// repeated .Class.Member members = 4;
inline int Class::members_size() const {
  return members_.size();
}
inline void Class::clear_members() {
  members_.Clear();
}
inline const ::Class_Member& Class::members(int index) const {
  // @@protoc_insertion_point(field_get:Class.members)
  return members_.Get(index);
}
inline ::Class_Member* Class::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:Class.members)
  return members_.Mutable(index);
}
inline ::Class_Member* Class::add_members() {
  // @@protoc_insertion_point(field_add:Class.members)
  return members_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Class_Member >*
Class::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:Class.members)
  return &members_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Class_Member >&
Class::members() const {
  // @@protoc_insertion_point(field_list:Class.members)
  return members_;
}

inline const Class* Class::internal_default_instance() {
  return &Class_default_instance_.get();
}
// -------------------------------------------------------------------

// Module_Member

// optional .Class cls = 1;
inline bool Module_Member::has_cls() const {
  return type_case() == kCls;
}
inline void Module_Member::set_has_cls() {
  _oneof_case_[0] = kCls;
}
inline void Module_Member::clear_cls() {
  if (has_cls()) {
    delete type_.cls_;
    clear_has_type();
  }
}
inline  const ::Class& Module_Member::cls() const {
  // @@protoc_insertion_point(field_get:Module.Member.cls)
  return has_cls()
      ? *type_.cls_
      : ::Class::default_instance();
}
inline ::Class* Module_Member::mutable_cls() {
  if (!has_cls()) {
    clear_type();
    set_has_cls();
    type_.cls_ = new ::Class;
  }
  // @@protoc_insertion_point(field_mutable:Module.Member.cls)
  return type_.cls_;
}
inline ::Class* Module_Member::release_cls() {
  // @@protoc_insertion_point(field_release:Module.Member.cls)
  if (has_cls()) {
    clear_has_type();
    ::Class* temp = type_.cls_;
    type_.cls_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Module_Member::set_allocated_cls(::Class* cls) {
  clear_type();
  if (cls) {
    set_has_cls();
    type_.cls_ = cls;
  }
  // @@protoc_insertion_point(field_set_allocated:Module.Member.cls)
}

// optional .Func func = 2;
inline bool Module_Member::has_func() const {
  return type_case() == kFunc;
}
inline void Module_Member::set_has_func() {
  _oneof_case_[0] = kFunc;
}
inline void Module_Member::clear_func() {
  if (has_func()) {
    delete type_.func_;
    clear_has_type();
  }
}
inline  const ::Func& Module_Member::func() const {
  // @@protoc_insertion_point(field_get:Module.Member.func)
  return has_func()
      ? *type_.func_
      : ::Func::default_instance();
}
inline ::Func* Module_Member::mutable_func() {
  if (!has_func()) {
    clear_type();
    set_has_func();
    type_.func_ = new ::Func;
  }
  // @@protoc_insertion_point(field_mutable:Module.Member.func)
  return type_.func_;
}
inline ::Func* Module_Member::release_func() {
  // @@protoc_insertion_point(field_release:Module.Member.func)
  if (has_func()) {
    clear_has_type();
    ::Func* temp = type_.func_;
    type_.func_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Module_Member::set_allocated_func(::Func* func) {
  clear_type();
  if (func) {
    set_has_func();
    type_.func_ = func;
  }
  // @@protoc_insertion_point(field_set_allocated:Module.Member.func)
}

// optional .VarDeclStmt var_decl = 3;
inline bool Module_Member::has_var_decl() const {
  return type_case() == kVarDecl;
}
inline void Module_Member::set_has_var_decl() {
  _oneof_case_[0] = kVarDecl;
}
inline void Module_Member::clear_var_decl() {
  if (has_var_decl()) {
    delete type_.var_decl_;
    clear_has_type();
  }
}
inline  const ::VarDeclStmt& Module_Member::var_decl() const {
  // @@protoc_insertion_point(field_get:Module.Member.var_decl)
  return has_var_decl()
      ? *type_.var_decl_
      : ::VarDeclStmt::default_instance();
}
inline ::VarDeclStmt* Module_Member::mutable_var_decl() {
  if (!has_var_decl()) {
    clear_type();
    set_has_var_decl();
    type_.var_decl_ = new ::VarDeclStmt;
  }
  // @@protoc_insertion_point(field_mutable:Module.Member.var_decl)
  return type_.var_decl_;
}
inline ::VarDeclStmt* Module_Member::release_var_decl() {
  // @@protoc_insertion_point(field_release:Module.Member.var_decl)
  if (has_var_decl()) {
    clear_has_type();
    ::VarDeclStmt* temp = type_.var_decl_;
    type_.var_decl_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Module_Member::set_allocated_var_decl(::VarDeclStmt* var_decl) {
  clear_type();
  if (var_decl) {
    set_has_var_decl();
    type_.var_decl_ = var_decl;
  }
  // @@protoc_insertion_point(field_set_allocated:Module.Member.var_decl)
}

// optional .ExternFunc extern_func = 4;
inline bool Module_Member::has_extern_func() const {
  return type_case() == kExternFunc;
}
inline void Module_Member::set_has_extern_func() {
  _oneof_case_[0] = kExternFunc;
}
inline void Module_Member::clear_extern_func() {
  if (has_extern_func()) {
    delete type_.extern_func_;
    clear_has_type();
  }
}
inline  const ::ExternFunc& Module_Member::extern_func() const {
  // @@protoc_insertion_point(field_get:Module.Member.extern_func)
  return has_extern_func()
      ? *type_.extern_func_
      : ::ExternFunc::default_instance();
}
inline ::ExternFunc* Module_Member::mutable_extern_func() {
  if (!has_extern_func()) {
    clear_type();
    set_has_extern_func();
    type_.extern_func_ = new ::ExternFunc;
  }
  // @@protoc_insertion_point(field_mutable:Module.Member.extern_func)
  return type_.extern_func_;
}
inline ::ExternFunc* Module_Member::release_extern_func() {
  // @@protoc_insertion_point(field_release:Module.Member.extern_func)
  if (has_extern_func()) {
    clear_has_type();
    ::ExternFunc* temp = type_.extern_func_;
    type_.extern_func_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Module_Member::set_allocated_extern_func(::ExternFunc* extern_func) {
  clear_type();
  if (extern_func) {
    set_has_extern_func();
    type_.extern_func_ = extern_func;
  }
  // @@protoc_insertion_point(field_set_allocated:Module.Member.extern_func)
}

inline bool Module_Member::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Module_Member::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Module_Member::TypeCase Module_Member::type_case() const {
  return Module_Member::TypeCase(_oneof_case_[0]);
}
inline const Module_Member* Module_Member::internal_default_instance() {
  return &Module_Member_default_instance_.get();
}
// -------------------------------------------------------------------

// Module

// optional string name = 1;
inline void Module::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Module::name() const {
  // @@protoc_insertion_point(field_get:Module.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Module::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Module.name)
}
inline void Module::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Module.name)
}
inline void Module::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Module.name)
}
inline ::std::string* Module::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Module.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Module::release_name() {
  // @@protoc_insertion_point(field_release:Module.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Module::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Module.name)
}

// repeated .Module.Member members = 2;
inline int Module::members_size() const {
  return members_.size();
}
inline void Module::clear_members() {
  members_.Clear();
}
inline const ::Module_Member& Module::members(int index) const {
  // @@protoc_insertion_point(field_get:Module.members)
  return members_.Get(index);
}
inline ::Module_Member* Module::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:Module.members)
  return members_.Mutable(index);
}
inline ::Module_Member* Module::add_members() {
  // @@protoc_insertion_point(field_add:Module.members)
  return members_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Module_Member >*
Module::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:Module.members)
  return &members_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Module_Member >&
Module::members() const {
  // @@protoc_insertion_point(field_list:Module.members)
  return members_;
}

inline const Module* Module::internal_default_instance() {
  return &Module_default_instance_.get();
}
// -------------------------------------------------------------------

// TypeSpec

// optional string name = 1;
inline void TypeSpec::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TypeSpec::name() const {
  // @@protoc_insertion_point(field_get:TypeSpec.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TypeSpec::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TypeSpec.name)
}
inline void TypeSpec::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TypeSpec.name)
}
inline void TypeSpec::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TypeSpec.name)
}
inline ::std::string* TypeSpec::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:TypeSpec.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TypeSpec::release_name() {
  // @@protoc_insertion_point(field_release:TypeSpec.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TypeSpec::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:TypeSpec.name)
}

// repeated .TypeSpec params = 2;
inline int TypeSpec::params_size() const {
  return params_.size();
}
inline void TypeSpec::clear_params() {
  params_.Clear();
}
inline const ::TypeSpec& TypeSpec::params(int index) const {
  // @@protoc_insertion_point(field_get:TypeSpec.params)
  return params_.Get(index);
}
inline ::TypeSpec* TypeSpec::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:TypeSpec.params)
  return params_.Mutable(index);
}
inline ::TypeSpec* TypeSpec::add_params() {
  // @@protoc_insertion_point(field_add:TypeSpec.params)
  return params_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::TypeSpec >*
TypeSpec::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:TypeSpec.params)
  return &params_;
}
inline const ::google::protobuf::RepeatedPtrField< ::TypeSpec >&
TypeSpec::params() const {
  // @@protoc_insertion_point(field_list:TypeSpec.params)
  return params_;
}

// optional .TypeSpec parent = 3;
inline bool TypeSpec::has_parent() const {
  return this != internal_default_instance() && parent_ != NULL;
}
inline void TypeSpec::clear_parent() {
  if (GetArenaNoVirtual() == NULL && parent_ != NULL) delete parent_;
  parent_ = NULL;
}
inline const ::TypeSpec& TypeSpec::parent() const {
  // @@protoc_insertion_point(field_get:TypeSpec.parent)
  return parent_ != NULL ? *parent_
                         : *::TypeSpec::internal_default_instance();
}
inline ::TypeSpec* TypeSpec::mutable_parent() {
  
  if (parent_ == NULL) {
    parent_ = new ::TypeSpec;
  }
  // @@protoc_insertion_point(field_mutable:TypeSpec.parent)
  return parent_;
}
inline ::TypeSpec* TypeSpec::release_parent() {
  // @@protoc_insertion_point(field_release:TypeSpec.parent)
  
  ::TypeSpec* temp = parent_;
  parent_ = NULL;
  return temp;
}
inline void TypeSpec::set_allocated_parent(::TypeSpec* parent) {
  delete parent_;
  parent_ = parent;
  if (parent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:TypeSpec.parent)
}

inline const TypeSpec* TypeSpec::internal_default_instance() {
  return &TypeSpec_default_instance_.get();
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::UnaryOpExpr_Op> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UnaryOpExpr_Op>() {
  return ::UnaryOpExpr_Op_descriptor();
}
template <> struct is_proto_enum< ::BinaryOpExpr_Op> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BinaryOpExpr_Op>() {
  return ::BinaryOpExpr_Op_descriptor();
}
template <> struct is_proto_enum< ::VarDeclStmt_Mode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::VarDeclStmt_Mode>() {
  return ::VarDeclStmt_Mode_descriptor();
}
template <> struct is_proto_enum< ::FuncParam_Mode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FuncParam_Mode>() {
  return ::FuncParam_Mode_descriptor();
}
template <> struct is_proto_enum< ::Func_ReturnMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Func_ReturnMode>() {
  return ::Func_ReturnMode_descriptor();
}
template <> struct is_proto_enum< ::Func_CC> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Func_CC>() {
  return ::Func_CC_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ast_2eproto__INCLUDED
