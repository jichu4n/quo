Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    CLASS
    FOR
    FUNCTION
    VAR

Grammar

Rule 0     S' -> type_spec
Rule 1     primary -> STRING_CONSTANT
Rule 2     primary -> INTEGER_CONSTANT
Rule 3     primary -> BOOLEAN_CONSTANT
Rule 4     primary -> IDENTIFIER
Rule 5     primary -> THIS
Rule 6     primary -> L_PAREN expr R_PAREN
Rule 7     primary -> primary DOT IDENTIFIER
Rule 8     primary -> primary L_BRACKET expr R_BRACKET
Rule 9     primary -> primary L_PAREN expr_list R_PAREN
Rule 10    unary_arith -> primary
Rule 11    unary_arith -> ADD unary_arith
Rule 12    unary_arith -> SUB unary_arith
Rule 13    binary_arith -> unary_arith
Rule 14    binary_arith -> binary_arith ADD binary_arith
Rule 15    binary_arith -> binary_arith SUB binary_arith
Rule 16    binary_arith -> binary_arith MUL binary_arith
Rule 17    binary_arith -> binary_arith DIV binary_arith
Rule 18    binary_arith -> binary_arith MOD binary_arith
Rule 19    binary_arith -> binary_arith EQ binary_arith
Rule 20    binary_arith -> binary_arith NE binary_arith
Rule 21    binary_arith -> binary_arith GT binary_arith
Rule 22    binary_arith -> binary_arith GE binary_arith
Rule 23    binary_arith -> binary_arith LT binary_arith
Rule 24    binary_arith -> binary_arith LE binary_arith
Rule 25    unary_bool -> binary_arith
Rule 26    unary_bool -> NOT unary_bool
Rule 27    binary_bool -> unary_bool
Rule 28    binary_bool -> binary_bool AND binary_bool
Rule 29    binary_bool -> binary_bool OR binary_bool
Rule 30    assign -> primary ASSIGN expr
Rule 31    assign -> primary ADD_ASSIGN expr
Rule 32    assign -> primary SUB_ASSIGN expr
Rule 33    assign -> primary MUL_ASSIGN expr
Rule 34    assign -> primary DIV_ASSIGN expr
Rule 35    expr -> binary_bool
Rule 36    expr -> assign
Rule 37    expr_list -> <empty>
Rule 38    expr_list -> expr
Rule 39    expr_list -> expr COMMA expr_list
Rule 40    type_spec_primary -> IDENTIFIER
Rule 41    type_spec_primary -> IDENTIFIER LT type_spec_list GT
Rule 42    type_spec -> type_spec_primary
Rule 43    type_spec -> type_spec DOT type_spec_primary
Rule 44    type_spec_list -> <empty>
Rule 45    type_spec_list -> type_spec
Rule 46    type_spec_list -> type_spec COMMA type_spec_list
Rule 47    expr_stmt -> expr SEMICOLON
Rule 48    return_stmt -> RETURN expr SEMICOLON
Rule 49    break_stmt -> BREAK SEMICOLON
Rule 50    continue_stmt -> CONTINUE SEMICOLON
Rule 51    cond_stmt_if -> IF expr L_BRACE stmts R_BRACE
Rule 52    cond_stmt -> cond_stmt_if
Rule 53    cond_stmt -> cond_stmt_if ELSE cond_stmt
Rule 54    cond_stmt -> cond_stmt_if ELSE L_BRACE stmts R_BRACE
Rule 55    cond_loop_stmt -> WHILE expr L_BRACE stmts R_BRACE
Rule 56    stmt -> expr_stmt
Rule 57    stmt -> return_stmt
Rule 58    stmt -> break_stmt
Rule 59    stmt -> continue_stmt
Rule 60    stmt -> cond_stmt
Rule 61    stmt -> cond_loop_stmt
Rule 62    stmts -> <empty>
Rule 63    stmts -> stmt stmts

Terminals, with rules where they appear

ADD                  : 11 14
ADD_ASSIGN           : 31
AND                  : 28
ASSIGN               : 30
BOOLEAN_CONSTANT     : 3
BREAK                : 49
CLASS                : 
COMMA                : 39 46
CONTINUE             : 50
DIV                  : 17
DIV_ASSIGN           : 34
DOT                  : 7 43
ELSE                 : 53 54
EQ                   : 19
FOR                  : 
FUNCTION             : 
GE                   : 22
GT                   : 21 41
IDENTIFIER           : 4 7 40 41
IF                   : 51
INTEGER_CONSTANT     : 2
LE                   : 24
LT                   : 23 41
L_BRACE              : 51 54 55
L_BRACKET            : 8
L_PAREN              : 6 9
MOD                  : 18
MUL                  : 16
MUL_ASSIGN           : 33
NE                   : 20
NOT                  : 26
OR                   : 29
RETURN               : 48
R_BRACE              : 51 54 55
R_BRACKET            : 8
R_PAREN              : 6 9
SEMICOLON            : 47 48 49 50
STRING_CONSTANT      : 1
SUB                  : 12 15
SUB_ASSIGN           : 32
THIS                 : 5
VAR                  : 
WHILE                : 55
error                : 

Nonterminals, with rules where they appear

assign               : 36
binary_arith         : 14 14 15 15 16 16 17 17 18 18 19 19 20 20 21 21 22 22 23 23 24 24 25
binary_bool          : 28 28 29 29 35
break_stmt           : 58
cond_loop_stmt       : 61
cond_stmt            : 53 60
cond_stmt_if         : 52 53 54
continue_stmt        : 59
expr                 : 6 8 30 31 32 33 34 38 39 47 48 51 55
expr_list            : 9 39
expr_stmt            : 56
primary              : 7 8 9 10 30 31 32 33 34
return_stmt          : 57
stmt                 : 63
stmts                : 51 54 55 63
type_spec            : 43 45 46 0
type_spec_list       : 41 46
type_spec_primary    : 42 43
unary_arith          : 11 12 13
unary_bool           : 26 27

Parsing method: LALR

state 0

    (0) S' -> . type_spec
    (42) type_spec -> . type_spec_primary
    (43) type_spec -> . type_spec DOT type_spec_primary
    (40) type_spec_primary -> . IDENTIFIER
    (41) type_spec_primary -> . IDENTIFIER LT type_spec_list GT

    IDENTIFIER      shift and go to state 3

    type_spec_primary              shift and go to state 1
    type_spec                      shift and go to state 2

state 1

    (42) type_spec -> type_spec_primary .

    COMMA           reduce using rule 42 (type_spec -> type_spec_primary .)
    DOT             reduce using rule 42 (type_spec -> type_spec_primary .)
    GT              reduce using rule 42 (type_spec -> type_spec_primary .)
    $end            reduce using rule 42 (type_spec -> type_spec_primary .)


state 2

    (0) S' -> type_spec .
    (43) type_spec -> type_spec . DOT type_spec_primary

    DOT             shift and go to state 4


state 3

    (40) type_spec_primary -> IDENTIFIER .
    (41) type_spec_primary -> IDENTIFIER . LT type_spec_list GT

    DOT             reduce using rule 40 (type_spec_primary -> IDENTIFIER .)
    $end            reduce using rule 40 (type_spec_primary -> IDENTIFIER .)
    COMMA           reduce using rule 40 (type_spec_primary -> IDENTIFIER .)
    GT              reduce using rule 40 (type_spec_primary -> IDENTIFIER .)
    LT              shift and go to state 5


state 4

    (43) type_spec -> type_spec DOT . type_spec_primary
    (40) type_spec_primary -> . IDENTIFIER
    (41) type_spec_primary -> . IDENTIFIER LT type_spec_list GT

    IDENTIFIER      shift and go to state 3

    type_spec_primary              shift and go to state 6

state 5

    (41) type_spec_primary -> IDENTIFIER LT . type_spec_list GT
    (44) type_spec_list -> .
    (45) type_spec_list -> . type_spec
    (46) type_spec_list -> . type_spec COMMA type_spec_list
    (42) type_spec -> . type_spec_primary
    (43) type_spec -> . type_spec DOT type_spec_primary
    (40) type_spec_primary -> . IDENTIFIER
    (41) type_spec_primary -> . IDENTIFIER LT type_spec_list GT

    GT              reduce using rule 44 (type_spec_list -> .)
    IDENTIFIER      shift and go to state 3

    type_spec_list                 shift and go to state 7
    type_spec_primary              shift and go to state 1
    type_spec                      shift and go to state 8

state 6

    (43) type_spec -> type_spec DOT type_spec_primary .

    COMMA           reduce using rule 43 (type_spec -> type_spec DOT type_spec_primary .)
    DOT             reduce using rule 43 (type_spec -> type_spec DOT type_spec_primary .)
    GT              reduce using rule 43 (type_spec -> type_spec DOT type_spec_primary .)
    $end            reduce using rule 43 (type_spec -> type_spec DOT type_spec_primary .)


state 7

    (41) type_spec_primary -> IDENTIFIER LT type_spec_list . GT

    GT              shift and go to state 9


state 8

    (45) type_spec_list -> type_spec .
    (46) type_spec_list -> type_spec . COMMA type_spec_list
    (43) type_spec -> type_spec . DOT type_spec_primary

    GT              reduce using rule 45 (type_spec_list -> type_spec .)
    COMMA           shift and go to state 10
    DOT             shift and go to state 4


state 9

    (41) type_spec_primary -> IDENTIFIER LT type_spec_list GT .

    DOT             reduce using rule 41 (type_spec_primary -> IDENTIFIER LT type_spec_list GT .)
    $end            reduce using rule 41 (type_spec_primary -> IDENTIFIER LT type_spec_list GT .)
    COMMA           reduce using rule 41 (type_spec_primary -> IDENTIFIER LT type_spec_list GT .)
    GT              reduce using rule 41 (type_spec_primary -> IDENTIFIER LT type_spec_list GT .)


state 10

    (46) type_spec_list -> type_spec COMMA . type_spec_list
    (44) type_spec_list -> .
    (45) type_spec_list -> . type_spec
    (46) type_spec_list -> . type_spec COMMA type_spec_list
    (42) type_spec -> . type_spec_primary
    (43) type_spec -> . type_spec DOT type_spec_primary
    (40) type_spec_primary -> . IDENTIFIER
    (41) type_spec_primary -> . IDENTIFIER LT type_spec_list GT

    GT              reduce using rule 44 (type_spec_list -> .)
    IDENTIFIER      shift and go to state 3

    type_spec_list                 shift and go to state 11
    type_spec_primary              shift and go to state 1
    type_spec                      shift and go to state 8

state 11

    (46) type_spec_list -> type_spec COMMA type_spec_list .

    GT              reduce using rule 46 (type_spec_list -> type_spec COMMA type_spec_list .)

