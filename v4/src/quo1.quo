// Memory allocation via simple first-fit algorithm.
//
// Chunk header is 16 bytes:
//   0  i32 - chunk size in bytes
//   4  i32 - next chunk header or 0
//   8  i32 - prev chunk header or 0
//   12 byte - used = 1, free = 0
//   16 chunk data
// Minimum chunk data size is 16 bytes (so total 32 bytes with header).
let memoryStart;
let memoryEnd;
fn memoryInit(start, end) {
  let size, chunk;
  if (start <= 0) {
    throw("Memory cannot start at 0");
  }
  size = end - start;
  if (size < 16) {
    throw("Memory must be greater than 16 bytes");
  }
  memoryStart = start;
  memoryEnd = end;
  chunk = start;
  store(chunk, memoryEnd - memoryStart - 16);
  store(chunk + 4, 0);
  store(chunk + 8, 0);
  store8(chunk + 12, 0);
}
fn malloc(size): Int {
  let sizeWithHeader, chunk, chunkSize, nextChunk, newChunk;
  if (size <= 0) {
    return 0;
  }
  size = (size + 15) / 16 * 16;
  sizeWithHeader = size + 16;
  chunk = memoryStart;
  while (chunk != 0) {
    chunkSize = load(chunk);
    nextChunk = load(chunk + 4);
    if (!load8_u(chunk + 12)) {
      if (chunkSize >= size + 32) {
        // Split current chunk and return it.
        //
        // Create new chunk.
        newChunk = chunk + 16 + size;
        store(newChunk, chunkSize - size - 16);
        store(newChunk + 4, nextChunk);
        store(newChunk + 8, chunk);
        store8(newChunk + 12, 0);
        // Update original next chunk.
        if (nextChunk) {
          store(nextChunk + 8, newChunk);
        }
        // Update current chunk.
        store(chunk, size);
        store(chunk + 4, newChunk);
        store8(chunk + 12, 1);
        return chunk + 16;
      } else if (chunkSize >= size) {
        // Just mark current chunk as used and return it
        store8(chunk + 12, 1);
        return chunk + 16;
      }
    }
    chunk = nextChunk;
  }
  throw("Out of memory");
}
fn free(ptr) {
  let chunk, size, prevChunk, nextChunk, nextNextChunk;
  if (ptr == 0 || ptr < memoryStart + 16 ||  ptr > memoryEnd - 16) {
    return;
  }
  chunk = ptr - 16;
  store8(chunk + 12, 0);
  size = load(chunk + 0);
  nextChunk = load(chunk + 4);
  prevChunk = load(chunk + 8);
  // Merge with prev chunk if prev chunk is free
  if (prevChunk && !load8_u(prevChunk + 12)) {
    chunk = prevChunk;
    size = load(chunk + 0) + size + 16;
    store(chunk + 0, size);
    store(chunk + 4, nextChunk);
    if (nextChunk) {
      store(nextChunk + 8, chunk);
    }
  }
  // Merge with next chunk if next chunk is free
  if (nextChunk && !load8_u(nextChunk + 12)) {
    size = size + load(nextChunk + 0) + 16;
    store(chunk + 0, size);
    nextNextChunk = load(nextChunk + 4);
    store(chunk + 4, nextNextChunk);
    if (nextNextChunk) {
      store(nextNextChunk + 8, chunk);
    }
  }
}

// String functions.
fn strlen(str): Int {
  let len;
  while (load8_u(str)) {
    len = len + 1;
    str = str + 1;
  }
  return len;
}
fn strcmp(str1, str2): Int {
  let c1, c2;
  while (1) {
    c1 = load8_u(str1);
    c2 = load8_u(str2);
    if (c1 == 0 || c2 == 0 || c1 != c2) {
      break;
    }
    str1 = str1 + 1;
    str2 = str2 + 1;
  }
  return c1 - c2;
}
fn strlistFind(strlist, str): Int {
  let index, c;
  index = 0;
  while (load8_u(strlist)) {
    if (strcmp(str, strlist) == 0) {
      return index;
    }
    strlist = strlist + strlen(strlist) + 1;
  }
  return -1;
}
fn strlistAppend(strlist, strlistSize, str) {
  let p, len;
  p = strlist;
  while (load8_u(strlist)) {
    p = p + strlen(strlist) + 1;
  }
  len = strlen(str);
  if ((p - strlist) + len + 2 > strlistSize) {
    throw("Exceeded maximum strlist size");
  }
  memcpy(p, str, len + 1);
}
fn strchr(str, c): Int {
  let c2;
  while (1) {
    c2 = load8_u(str);
    if (!c2) {
      return 0;
    }
    if (c2 == c) {
      return str;
    }
    str = str + 1;
  }
}
fn strcat(str1, str1Size, str2) {
  let len1, len2;
  len1 = strlen(str1);
  len2 = strlen(str2);
  if (len1 + len2 + 1 > str1Size) {
    throw("Exceeded maximum string size in strcat");
  }
  memcpy(str1 + len1, str2, len2 + 1);
}
fn strcpy(dest, destSize, src) {
  let srcLen;
  srcLen = strlen(src);
  if (srcLen + 1 > destSize) {
    throw("Exceeded maximum string size in strcpy");
  }
  memcpy(dest, src, srcLen + 1);
}
fn isspace(c): Int {
  return c == 32 || c == 9 || c == 13 || c == 10;
}
fn isdigit(c): Int {
  return c >= 48 && c <= 57;
}
fn isalpha(c): Int {
  return c >= 65 && c <= 90 || c >= 97 && c <= 122;
}
fn isalnum(c): Int {
  return isdigit(c) || isalpha(c);
}
fn isident(c): Int {
  return isalnum(c) || c == 95; // _
}
fn itoa(num): String {
  let str, p;
  str = malloc(12);
  p = str + 10;
  while (1) {
    store8(p, num % 10 + 48);
    p = p - 1;
    num = num / 10;
    if (num == 0) {
      break;
    }
  }
  return p;
}

fn compileModule(): String {
  return "(module)";
}
fn init(input) {
  // Usable memory is between end of input and 15MB where we'll place string literals.
  memoryInit((input + strlen(input) + 1 + 3) / 4 * 4, 15728640);
}
