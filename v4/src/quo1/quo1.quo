// Memory allocation via simple first-fit algorithm.
//
// Chunk header is 16 bytes:
//   0  i32 - chunk size in bytes
//   4  i32 - next chunk header or 0
//   8  i32 - prev chunk header or 0
//   12 byte - used = 1, free = 0
//   16 chunk data
// Minimum chunk data size is 16 bytes (so total 32 bytes with header).
let memoryStart;
let memoryEnd;
fn memoryInit(start, end) {
  let size, chunk;
  if (start <= 0) {
    throw("Memory cannot start at 0");
  }
  size = end - start;
  if (size < 16) {
    throw("Memory must be greater than 16 bytes");
  }
  memoryStart = start;
  memoryEnd = end;
  chunk = start;
  store(chunk, memoryEnd - memoryStart - 16);
  store(chunk + 4, 0);
  store(chunk + 8, 0);
  store8(chunk + 12, 0);
}
fn malloc(size): Int {
  let sizeWithHeader, chunk, chunkSize, nextChunk, newChunk;
  if (size <= 0) {
    return 0;
  }
  size = (size + 15) / 16 * 16;
  sizeWithHeader = size + 16;
  chunk = memoryStart;
  while (chunk != 0) {
    chunkSize = load(chunk);
    nextChunk = load(chunk + 4);
    if (!load8_u(chunk + 12)) {
      if (chunkSize >= size + 32) {
        // Split current chunk and return it.
        //
        // Create new chunk.
        newChunk = chunk + 16 + size;
        store(newChunk, chunkSize - size - 16);
        store(newChunk + 4, nextChunk);
        store(newChunk + 8, chunk);
        store8(newChunk + 12, 0);
        // Update original next chunk.
        if (nextChunk) {
          store(nextChunk + 8, newChunk);
        }
        // Update current chunk.
        store(chunk, size);
        store(chunk + 4, newChunk);
        store8(chunk + 12, 1);
        return chunk + 16;
      } else if (chunkSize >= size) {
        // Just mark current chunk as used and return it
        store8(chunk + 12, 1);
        return chunk + 16;
      }
    }
    chunk = nextChunk;
  }
  throw("Out of memory");
}
fn free(ptr) {
  let chunk, size, prevChunk, nextChunk, nextNextChunk;
  if (ptr == 0 || ptr < memoryStart + 16 ||  ptr > memoryEnd - 16) {
    return;
  }
  chunk = ptr - 16;
  store8(chunk + 12, 0);
  size = load(chunk + 0);
  nextChunk = load(chunk + 4);
  prevChunk = load(chunk + 8);
  // Merge with prev chunk if prev chunk is free
  if (prevChunk && !load8_u(prevChunk + 12)) {
    chunk = prevChunk;
    size = load(chunk + 0) + size + 16;
    store(chunk + 0, size);
    store(chunk + 4, nextChunk);
    if (nextChunk) {
      store(nextChunk + 8, chunk);
    }
  }
  // Merge with next chunk if next chunk is free
  if (nextChunk && !load8_u(nextChunk + 12)) {
    size = size + load(nextChunk + 0) + 16;
    store(chunk + 0, size);
    nextNextChunk = load(nextChunk + 4);
    store(chunk + 4, nextNextChunk);
    if (nextNextChunk) {
      store(nextNextChunk + 8, chunk);
    }
  }
}

// Strings.
//
// Strings are represented as a header and a linked list of chunks. This
// representation helps reduce copying when building strings, which is a common
// operation during compilation.
//
// A string must have at least 1 chunk and at most 8 chunks.
// Each chunk starts off with at least 32 bytes and grows by a factor of 2.
//
// String header is 8 bytes:
//   00 i32 - string length
//   04 i32 - first chunk address (always non-null)
//
//  Chunk header is 12 bytes:
//    00 i32 - chunk size
//    04 i32 - length of string in chunk
//    08 i32 - next chunk address, 0 if last chunk
//    12 data
fn strNew(reserveLen): Int {
  let str, newChunk, len;
  str = malloc(8);
  len = (reserveLen + 3) / 4 * 4;
  if (len < 32) {
    len = 32;
  }
  newChunk = malloc(12 + len);
  store(str + 0, 0);
  store(str + 4, newChunk);
  store(newChunk + 0, len);
  store(newChunk + 4, 0);
  store(newChunk + 8, 0);
  return str;
}
fn strFromRaw(rawStr): Int {
  let len, str, chunk;
  len = rawStrLen(rawStr);
  str = strNew(len);
  store(str + 0, len);
  chunk = load(str + 4);
  store(chunk + 4, len);
  memcpy(chunk + 12, rawStr, len);
  return str;
}
fn strDelete(str) {
  let chunk, nextChunk;
  chunk = load(str + 4);
  while (chunk) {
    nextChunk = load(chunk + 8);
    free(chunk);
    chunk = nextChunk;
  }
  free(str);
}
fn strFlatten(str) {
  let len, chunk, chunkSize, chunkLen, newChunkSize, newChunk, nextChunk, nextNextChunk, nextChunkLen;
  len = load(str + 0);
  chunk = load(str + 4);
  chunkLen = load(chunk + 4);
  if (len == chunkLen) {
    return;
  }
  chunkSize = load(chunk + 0);
  nextChunk = load(chunk + 8);
  // If first chunk is not large enough to hold entire string, replace it with a
  // new chunk that has sufficient size.
  if (chunkSize < len) {
    newChunkSize = (len + 3) / 4 * 4;
    newChunk = malloc(12 + newChunkSize);
    store(newChunk + 0, newChunkSize);
    memcpy(newChunk + 12, chunk + 12, chunkLen);
    free(chunk);
    store(str + 4, newChunk);
    chunkSize = newChunkSize;
    chunk = newChunk;
  }
  store(chunk + 4, len);
  store(chunk + 8, 0);
  while (nextChunk) {
    nextChunkLen = load(nextChunk + 4);
    nextNextChunk = load(nextChunk + 8);
    if (nextChunkLen) {
      memcpy(chunk + 12 + chunkLen, nextChunk + 12, nextChunkLen);
      chunkLen = chunkLen + nextChunkLen;
    }
    free(nextChunk);
    nextChunk = nextNextChunk;
  }
}
fn strToRaw(str): Int {
  let len, chunk, result;
  strFlatten(str);
  len = load(str + 0);
  chunk = load(str + 4);
  result = malloc(len + 1);
  memcpy(result, chunk + 12, len);
  store8(result + len, 0);
  return result;
}
// Append str2 to str1 and delete str2.
fn strMerge(str1, str2): Int {
  let str1Len, str2Len, str1Chunk, str2Chunk, str1ChunkSize, str1ChunkLen, str2ChunkLen;
  str1Len = load(str1 + 0);
  str2Len = load(str2 + 0);

  // Special case: if both strings are empty, nothing to do.
  if (str1Len == 0 && str2Len == 0) {
    strDelete(str2);
    return str1;
  }

  store(str1 + 0, str1Len + str2Len);
  // Special case: if str1 is empty but str2 isn't, take ownership of str2's
  // chunks.
  if (str1Len == 0) {
    str1Chunk = load(str1 + 4);
    str2Chunk = load(str2 + 4);
    free(str1Chunk);
    store(str1 + 4, str2Chunk);
    free(str2);
    return str1;
  }

  str1Chunk = strTailChunk(str1);
  str2Chunk = load(str2 + 4);
  str1ChunkSize = load(str1Chunk + 0);
  str1ChunkLen = load(str1Chunk + 4);
  str2ChunkLen = load(str2Chunk + 4);
  if (str1ChunkLen + str2ChunkLen <= str1ChunkSize) {
    // Merge str2's first chunk with str1's last chunk if possible.
    store(str1Chunk + 4, str1ChunkLen + str2ChunkLen);
    store(str1Chunk + 8, load(str2Chunk + 8));
    memcpy(str1Chunk + 12 + str1ChunkLen, str2Chunk + 12, str2ChunkLen);
    free(str2Chunk);
    free(str2);
  } else {
    // Else, add str2's first chunk after str1's last chunk.
    store(str1Chunk + 8, str2Chunk);
    free(str2);
  }
  return str1;
}
fn strAppendRaw(str1, str2): Int {
  let str1Len, str2Len, chunk, chunkSize, chunkLen, newChunk, newChunkLen;
  str2Len = rawStrLen(str2);
  if (str2Len == 0) {
    return str1;
  }
  str1Len = load(str1 + 0);
  store(str1 + 0, str1Len + str2Len);
  chunk = strTailChunk(str1);
  chunkSize = load(chunk + 0);
  chunkLen = load(chunk + 4);
  if (chunkLen + str2Len < chunkSize) {
    // Merge str2 into last chunk.
    store(chunk + 4, chunkLen + str2Len);
    memcpy(chunk + 12 + chunkLen, str2, str2Len);
  } else {
    // Create new chunk.
    newChunkLen = (str2Len + 3) / 4 * 4;
    if (newChunkLen < 32) {
      newChunkLen = 32;
    }
    newChunk = malloc(12 + newChunkLen);
    store(newChunk + 0, newChunkLen);
    store(newChunk + 4, str2Len);
    store(newChunk + 8, 0);
    memcpy(newChunk + 12, str2, str2Len);
    store(chunk + 8, newChunk);
  }
  return str1;
}
fn strTailChunk(str): Int {
  let chunk, nextChunk;
  chunk = load(str + 4);
  while (1) {
    nextChunk = load(chunk + 8);
    if (!nextChunk) {
      return chunk;
    }
    chunk = nextChunk;
  }
}


// Raw (i.e., C-style, null terminated) strings.
fn rawStrLen(str): Int {
  let len;
  while (load8_u(str)) {
    len = len + 1;
    str = str + 1;
  }
  return len;
}
fn itoa(n, str): Int {
  let p;
  p = str + 11;
  store8(p, 0);
  while (1) {
    p = p - 1;
    store8(p, n % 10 + 48);
    n = n / 10;
    if (n == 0) {
      break;
    }
  }
  return p;
}

// Entry point.
fn compileModule(): String {
  return "(module)";
}
fn init(input) {
  // Usable memory is between end of input and 15MB where we'll place string literals.
  memoryInit((input + rawStrLen(input) + 1 + 3) / 4 * 4, 15728640);
}
