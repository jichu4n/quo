// Symbol tables.
let globalVars, localVars, fns, stringConstantOffsets, nextStringConstantOffset;
fn symbolsInit(stringConstantOffset) {
  globalVars = dictNew(0);
  localVars = dictNew(0);
  fns = dictNew(0);
  stringConstantOffsets = dictNew(0);
  nextStringConstantOffset = stringConstantOffset;
}
fn symbolsCleanUp() {
  dictDelete(globalVars, 0);
  dictDelete(localVars, 0);
  dictDelete(fns, 0);
  dictDelete(stringConstantOffsets, 0);
  nextStringConstantOffset = 0;
}
fn addGlobalVar(name) {
  dictSet(globalVars, name, 1, 0);
}
fn isGlobalVar(name) {
  return dictFind(globalVars, name) >= 0;
}
fn addLocalVar(name) {
  dictSet(localVars, name, 1, 0);
}
fn isLocalVar(name) {
  return dictFind(localVars, name) >= 0;
}
fn getOrAddStringConstantOffset(str) {
  let offset;
  offset = dictGet(stringConstantOffsets, str);
  if (offset) {
    return offset;
  }
  offset = nextStringConstantOffset;
  dictSet(stringConstantOffsets, str, offset, 0);
  nextStringConstantOffset = nextStringConstantOffset + strLen(str) + 1;
  return offset;
}

// Pointer to next char in input string.
let inputPtr;

// Single pass parser + code generator.
fn compileExpr0() {
  let token, tokenValue, token2, tokenValue2, output, origInputPtr, outputPrefix;

  tokenValue = strNew(0);
  token = nextToken(tokenValue);

  // Number literal
  if (token == 1) {
    output = strFromRaw("(i32.const ");
    strMerge(output, tokenValue);
    strPushRaw(output, ")");
    return output;
  }

  // String literal
  if (token == 2) {
    output = strFromRaw("(i32.const ");
    strPushInt(output, getOrAddStringConstantOffset(tokenValue));
    strDelete(tokenValue);
    strPushRaw(output, ")");
    return output;
  }

  // Parenthesis
  if (token == 40) {
    output = compileExpr();
    expectToken(41, tokenValue);
    strDelete(tokenValue);
    return output;
  }

  // Identifier or function call
  if (token == 3) {
    origInputPtr = inputPtr;
    tokenValue2 = strNew(0);
    token2 = nextToken(tokenValue2);
    if (token2 == 40) {  // (
      // Function call
      output = strFromRaw("(call $");
      strMerge(output, tokenValue);
      origInputPtr = inputPtr;
      token2 = nextToken(tokenValue2);
      if (token2 != 41)  {  // )
        inputPtr = origInputPtr;
        while (1) {
          strPushRaw(output, " ");
          strMerge(output, compileExpr());
          token2 = nextToken(tokenValue2);
          if (token2 == 41) {  // close parenthesis
            break;
          } else if (token2 == 44) { // ,
            // Do nothing
          } else {
            throw("Expected ',' or ')' after function call argument");
          }
        }
      }
      strPushRaw(output, ")");
      strDelete(tokenValue2);
    } else {
      // Identifier
      inputPtr = origInputPtr;
      if (isLocalVar(tokenValue)) {
        outputPrefix = "(local.get $";
      } else if (isGlobalVar(tokenValue)) {
        outputPrefix = "(global.get $";
      } else {
        output = strFromRaw("Undeclared variable '");
        strMerge(output, tokenValue);
        strPushRaw(output, "'");
        throw(strToRaw(output));
      }
      output = strFromRaw(outputPrefix);
      strMerge(output, tokenValue);
      strPushRaw(output, ")");
    }
    return output;
  }

  output = strFromRaw("Expected expression, got token type ");
  strPushInt(output, token);
  strPushRaw(output, " with value '");
  strMerge(output, tokenValue);
  strPushRaw(output, "'");
  throw(strToRaw(output));
}
fn compileExpr1() {
  let token, tokenValue, output, rightOutput, origInputPtr, outputPrefix;
  origInputPtr = inputPtr;
  tokenValue = strNew(0);
  token = nextToken(tokenValue);
  strDelete(tokenValue);
  if (token == 45) {  // -
    outputPrefix = "(i32.neg ";
  } else if (token == 33) {  // !
    outputPrefix = "(i32.eqz ";
  } else {
    inputPtr = origInputPtr;
    return compileExpr0();
  }
  output = strFromRaw(outputPrefix);
  strMerge(output, compileExpr0());
  strPushRaw(output, ")");
  return output;
}
fn compileExpr() {
  return compileExpr1();
}
fn expectToken(expectedToken, tokenValue) {
  let actualToken, output;
  actualToken = nextToken(tokenValue);
  if (actualToken != expectedToken) {
    output = strFromRaw("Expected token ");
    strPushInt(output, expectedToken);
    strPushRaw(output, ", but received token ");
    strPushInt(output, actualToken);
    strPushRaw(output, " with value '");
    strMerge(output, tokenValue);
    strPushRaw(output, "'");
    throw(strToRaw(output));
  }
}


// Lexer.
//
// Token types:
//   00 - EOF
//   01 - Number literal
//   02 - String literal
//   03 - Identifier
//   04 - fn
//   05 - let
//   06 - if
//   07 - else
//   08 - while
//   09 - return
//   10 - break
//   11 - continue
// Single letter operators and symbol are their ASCII value. Double letter
// operators are 128 + the ASCII value of the first letter.
let keywords;
let twoCharOperators;
fn lexerInit(input) {
  inputPtr = input;
  keywords = dictNew(16);
  // Keywords in the order of their values.
  dictSetRaw(keywords, "fn", 1, 0);
  dictSetRaw(keywords, "let", 1, 0);
  dictSetRaw(keywords, "if", 1, 0);
  dictSetRaw(keywords, "else", 1, 0);
  dictSetRaw(keywords, "while", 1, 0);
  dictSetRaw(keywords, "return", 1, 0);
  dictSetRaw(keywords, "break", 1, 0);
  dictSetRaw(keywords, "continue", 1, 0);
  twoCharOperators = dictNew(16);
  dictSetRaw(twoCharOperators, "==", 1, 0);
  dictSetRaw(twoCharOperators, "!=", 1, 0);
  dictSetRaw(twoCharOperators, "<=", 1, 0);
  dictSetRaw(twoCharOperators, ">=", 1, 0);
  dictSetRaw(twoCharOperators, "&&", 1, 0);
  dictSetRaw(twoCharOperators, "||", 1, 0);
}
fn lexerCleanUp() {
  dictDelete(keywords, 0);
  dictDelete(twoCharOperators, 0);
}
fn nextToken(tokenValue) {
  let c, c2;

  strClear(tokenValue);
  skipWhitespaceAndComments();
  c = curChar();

  // EOF
  if (c == 0) {
    return 0;
  }

  // Number literal
  if (isDigit(c)
    || (c == 45 && isDigit(peekNextChar()))) {  // -
    while (1) {
      strPush(tokenValue, c);
      c = nextChar();
      if (!isDigit(c)) {
        break;
      }
    }
    return 1;
  }

  // String literal
  if (c == 34) {  // "
    while (1) {
      c = nextChar();
      if (c == 0) {
        throw("Unterminated string literal");
      }
      if (c == 34) {  // "
        break;
      }
      strPush(tokenValue, c);
    }
    nextChar();
    return 2;
  }

  // Identifier or keyword.
  if (isIdent(c)) {
    while (isIdent(c)) {
      strPush(tokenValue, c);
      c = nextChar();
    }
    return 4 + dictFind(keywords, tokenValue);
  }

  // Operators.
  if (strchr("(){}[]<>=+-*/%!&|.,;:^", c)) {
    strPush(tokenValue, c);
    strPush(tokenValue, nextChar());
    if (dictFind(twoCharOperators, tokenValue) >= 0) {
      nextChar();
      return c + 128;
    } else {
      strPop(tokenValue);
      return c;
    }
  }

  throw("Unrecognized character");
}
fn peekNextToken(tokenValue) {
  let origInputPtr, token;
  origInputPtr = inputPtr;
  token = nextToken(tokenValue);
  inputPtr = origInputPtr;
  return token;
}
fn skipWhitespaceAndComments() {
  let c;
  c = curChar();
  while (1) {
    if (isSpace(c)) {
      c = nextChar();
    } else if (c == 47 && peekNextChar() == 47) {  // "/"
      nextChar();
      c = nextChar();
      while (c != 10 && c != 0) {  // LF
        c = nextChar();
      }
    } else {
      break;
    }
  }
}
fn nextChar() {
  inputPtr = inputPtr + 1;
  return load8_u(inputPtr);
}
fn peekNextChar() {
  return load8_u(inputPtr + 1);
}
fn curChar() {
  return load8_u(inputPtr);
}
fn isSpace(c) {
  return c == 32  // space
    || c == 9     // tab
    || c == 13    // CR
    || c == 10;   // LF
}
fn isDigit(c) {
  return c >= 48  // 0
    && c <= 57;   // 9
}
fn isAlpha(c) {
  return (c >= 65 && c <= 90) || (c >= 97 && c <= 122);
}
fn isIdent(c) {
  return isAlpha(c) || isDigit(c) || c == 95; // _
}
fn strchr(rawStr, c) {
  let c2;
  while (1) {
    c2 = load8_u(rawStr);
    if (c2 == 0) {
      return 0;
    }
    if (c == c2) {
      return rawStr;
    }
    rawStr = rawStr + 1;
  }
}


// Entry point.
fn compileModule() {
  return "  ;; placeholder";
}
fn indent(indentLevel) {
  let str, i;
  str = strNew(indentLevel * 2);
  i = 0;
  while (i < indentLevel) {
    strPushRaw(str, "  ");
    i = i + 1;
  }
  return str;
}
fn init(input, heapStart, heapEnd) {
  memoryInit(heapStart, heapEnd);
  lexerInit(input);
  symbolsInit(heapEnd);
}
fn cleanUp() {
  lexerCleanUp();
  symbolsCleanUp();
}
