// Symbol tables.
let globalVars, localVars, fns, stringConstantOffsets, nextStringConstantOffset;
fn symbolsInit(stringConstantOffset) {
  globalVars = dictNew(0);
  localVars = dictNew(0);
  fns = dictNew(0);
  stringConstantOffsets = dictNew(0);
  nextStringConstantOffset = stringConstantOffset;
}
fn addGlobalVar(name) {
  dictSet(globalVars, name, 1, 0);
}
fn isGlobalVar(name) {
  return dictFind(globalVars, name) >= 0;
}
fn addLocalVar(name) {
  dictSet(localVars, name, 1, 0);
}
fn isLocalVar(name) {
  return dictFind(localVars, name) >= 0;
}
fn getOrAddStringConstantOffset(str): Int {
  let offset;
  offset = dictGet(stringConstantOffsets, str);
  if (offset) {
    return offset;
  }
  offset = nextStringConstantOffset;
  dictSet(stringConstantOffsets, str, offset, 0);
  nextStringConstantOffset = nextStringConstantOffset + strLen(str) + 1;
  return offset;
}

// Single pass parser + code generator.
fn compileExpr0(): Int {
  let token, tokenValue, output, origInputPtr;

  tokenValue = strNew(0);
  token = nextToken(tokenValue);

  // Number literal
  if (token == 1) {
    output = strFromRaw("(i32.const ");
    strMerge(output, tokenValue);
    strPushRaw(output, ")");
    return output;
  }

  // String literal
  if (token == 2) {
    output = strFromRaw("(i32.const ");
    strPushInt(output, getOrAddStringConstantOffset(tokenValue));
    strDelete(tokenValue);
    strPushRaw(output, ")");
    return output;
  }

  // Parenthesis
  if (token == 40) {
    output = compileExpr();
    expectToken(41, tokenValue);
    strDelete(tokenValue);
    return output;
  }

  throw(
    strToRaw(
      strMerge(
        strPushRaw(
          strPushInt(strFromRaw("Expected expression, got token type "), token),
          " with value: "),
        tokenValue)));
}
fn compileExpr(): Int {
  return compileExpr0();
}
fn expectToken(expectedToken, tokenValue) {
  let actualToken;
  actualToken = nextToken(tokenValue);
  if (actualToken != expectedToken) {
    throw(strToRaw(
      strMerge(
        strPushRaw(
          strPushInt(
            strPushRaw(
              strPushInt(strFromRaw("Expected token type "), expectedToken),
              ", but received token "),
            actualToken),
          " with value "),
        tokenValue)));
  }
}


// Lexer.
//
// Token types:
//   00 - EOF
//   01 - Number literal
//   02 - String literal
//   03 - Identifier
//   04 - fn
//   05 - let
//   06 - if
//   07 - else
//   08 - while
//   09 - return
//   10 - break
//   11 - continue
// Single letter operators and symbol are their ASCII value. Double letter
// operators are 128 + the ASCII value of the first letter.
let inputPtr;
let keywords;
let twoCharOperators;
fn lexerInit(input) {
  inputPtr = input;
  keywords = dictNew(16);
  // Keywords in the order of their values.
  dictSetRaw(keywords, "fn", 1, 0);
  dictSetRaw(keywords, "let", 1, 0);
  dictSetRaw(keywords, "if", 1, 0);
  dictSetRaw(keywords, "else", 1, 0);
  dictSetRaw(keywords, "while", 1, 0);
  dictSetRaw(keywords, "return", 1, 0);
  dictSetRaw(keywords, "break", 1, 0);
  dictSetRaw(keywords, "continue", 1, 0);
  twoCharOperators = dictNew(16);
  dictSetRaw(twoCharOperators, "==", 1, 0);
  dictSetRaw(twoCharOperators, "!=", 1, 0);
  dictSetRaw(twoCharOperators, "<=", 1, 0);
  dictSetRaw(twoCharOperators, ">=", 1, 0);
  dictSetRaw(twoCharOperators, "&&", 1, 0);
  dictSetRaw(twoCharOperators, "||", 1, 0);
}
fn nextToken(tokenValue): Int {
  let c, c2;

  strClear(tokenValue);
  skipWhitespaceAndComments();
  c = curChar();

  // EOF
  if (c == 0) {
    return 0;
  }

  // Number literal
  if (isDigit(c)
    || (c == 45 && isDigit(peekNextChar()))) {  // -
    while (1) {
      strPush(tokenValue, c);
      c = nextChar();
      if (!isDigit(c)) {
        break;
      }
    }
    return 1;
  }

  // String literal
  if (c == 34) {  // "
    while (1) {
      c = nextChar();
      if (c == 0) {
        throw("Unterminated string literal");
      }
      if (c == 34) {  // "
        break;
      }
      strPush(tokenValue, c);
    }
    nextChar();
    return 2;
  }

  // Identifier or keyword.
  if (isIdent(c)) {
    while (isIdent(c)) {
      strPush(tokenValue, c);
      c = nextChar();
    }
    return 4 + dictFind(keywords, tokenValue);
  }

  // Operators.
  if (strchr("(){}[]<>=+-*/%!&|.,;:^", c)) {
    strPush(tokenValue, c);
    strPush(tokenValue, nextChar());
    if (dictFind(twoCharOperators, tokenValue) >= 0) {
      nextChar();
      return c + 128;
    } else {
      strPop(tokenValue);
      return c;
    }
  }

  throw("Unrecognized character");
}
fn peekNextToken(tokenValue): Int {
  let origInputPtr, token;
  origInputPtr = inputPtr;
  token = nextToken(tokenValue);
  inputPtr = origInputPtr;
  return token;
}
fn skipWhitespaceAndComments() {
  let c;
  c = curChar();
  while (1) {
    if (isSpace(c)) {
      c = nextChar();
    } else if (c == 47 && peekNextChar() == 47) {  // "/"
      nextChar();
      c = nextChar();
      while (c != 10 && c != 0) {  // LF
        c = nextChar();
      }
    } else {
      break;
    }
  }
}
fn nextChar(): Int {
  inputPtr = inputPtr + 1;
  return load8_u(inputPtr);
}
fn peekNextChar(): Int {
  return load8_u(inputPtr + 1);
}
fn curChar(): Int {
  return load8_u(inputPtr);
}
fn isSpace(c): Int {
  return c == 32  // space
    || c == 9     // tab
    || c == 13    // CR
    || c == 10;   // LF
}
fn isDigit(c): Int {
  return c >= 48  // 0
    && c <= 57;   // 9
}
fn isAlpha(c): Int {
  return (c >= 65 && c <= 90) || (c >= 97 && c <= 122);
}
fn isIdent(c): Int {
  return isAlpha(c) || isDigit(c) || c == 95; // _
}
fn strchr(rawStr, c): Int {
  let c2;
  while (1) {
    c2 = load8_u(rawStr);
    if (c2 == 0) {
      return 0;
    }
    if (c == c2) {
      return rawStr;
    }
    rawStr = rawStr + 1;
  }
}


// Entry point.
fn compileModule(): String {
  return "  ;; placeholder";
}
fn indent(indentLevel): String {
  let str, i;
  str = strNew(indentLevel * 2);
  i = 0;
  while (i < indentLevel) {
    strPushRaw(str, "  ");
    i = i + 1;
  }
  return str;
}
fn init(input, stringConstantOffset) {
  // Usable memory is between end of input and 15MB where we'll place string literals.
  memoryInit((input + rawStrLen(input) + 1 + 3) / 4 * 4, stringConstantOffset);
  lexerInit(input);
  symbolsInit(stringConstantOffset);
}
