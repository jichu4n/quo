// Memory allocation via simple first-fit algorithm.
//
// Chunk header is 16 bytes:
//   0  i32 - chunk size in bytes
//   4  i32 - next chunk header or 0
//   8  i32 - prev chunk header or 0
//   12 byte - used = 1, free = 0
//   16 chunk data
// Minimum chunk data size is 16 bytes (so total 32 bytes with header).
let memoryStart;
let memoryEnd;
fn memoryInit(start, end) {
  let size, chunk;
  if (start <= 0) {
    throw("Memory cannot start at 0");
  }
  size = end - start;
  if (size < 16) {
    throw("Memory must be greater than 16 bytes");
  }
  memoryStart = start;
  memoryEnd = end;
  chunk = start;
  store(chunk, memoryEnd - memoryStart - 16);
  store(chunk + 4, 0);
  store(chunk + 8, 0);
  store8(chunk + 12, 0);
}
fn malloc(size): Int {
  let sizeWithHeader, chunk, chunkSize, nextChunk, newChunk;
  if (size <= 0) {
    return 0;
  }
  size = (size + 15) / 16 * 16;
  sizeWithHeader = size + 16;
  chunk = memoryStart;
  while (chunk != 0) {
    chunkSize = load(chunk);
    nextChunk = load(chunk + 4);
    if (!load8_u(chunk + 12)) {
      if (chunkSize >= size + 32) {
        // Split current chunk and return it.
        //
        // Create new chunk.
        newChunk = chunk + 16 + size;
        store(newChunk, chunkSize - size - 16);
        store(newChunk + 4, nextChunk);
        store(newChunk + 8, chunk);
        store8(newChunk + 12, 0);
        // Update original next chunk.
        if (nextChunk) {
          store(nextChunk + 8, newChunk);
        }
        // Update current chunk.
        store(chunk, size);
        store(chunk + 4, newChunk);
        store8(chunk + 12, 1);
        return chunk + 16;
      } else if (chunkSize >= size) {
        // Just mark current chunk as used and return it
        store8(chunk + 12, 1);
        return chunk + 16;
      }
    }
    chunk = nextChunk;
  }
  throw("Out of memory");
}
fn free(ptr) {
  let chunk, size, prevChunk, nextChunk, nextNextChunk;
  if (ptr == 0 || ptr < memoryStart + 16 ||  ptr > memoryEnd - 16) {
    return;
  }
  chunk = ptr - 16;
  store8(chunk + 12, 0);
  size = load(chunk + 0);
  nextChunk = load(chunk + 4);
  prevChunk = load(chunk + 8);
  // Merge with prev chunk if prev chunk is free
  if (prevChunk && !load8_u(prevChunk + 12)) {
    chunk = prevChunk;
    size = load(chunk + 0) + size + 16;
    store(chunk + 0, size);
    store(chunk + 4, nextChunk);
    if (nextChunk) {
      store(nextChunk + 8, chunk);
    }
  }
  // Merge with next chunk if next chunk is free
  if (nextChunk && !load8_u(nextChunk + 12)) {
    size = size + load(nextChunk + 0) + 16;
    store(chunk + 0, size);
    nextNextChunk = load(nextChunk + 4);
    store(chunk + 4, nextNextChunk);
    if (nextNextChunk) {
      store(nextNextChunk + 8, chunk);
    }
  }
}

// Strings.
//
// Strings are represented as a header and a linked list of chunks. This
// representation helps reduce copying when building strings, which is a common
// operation during compilation.
//
// A string must have at least 1 chunk and at most 8 chunks.
// Each chunk starts off with at least 32 bytes and grows by a factor of 2.
//
// String header is 8 bytes:
//   00 i32 - string length
//   04 i32 - first chunk address (always non-null)
//
//  Chunk header is 12 bytes:
//    00 i32 - chunk size
//    04 i32 - length of string in chunk
//    08 i32 - next chunk address, 0 if last chunk
//    12 data
fn strNew(reserveLen): Int {
  let str;
  str = malloc(8);
  store(str + 0, 0);
  store(str + 4, strNewChunk(reserveLen, 0, 0, 0));
  return str;
}
fn strFromRaw(rawStr): Int {
  let len, str;
  len = rawStrLen(rawStr);
  str = malloc(8);
  store(str + 0, len);
  store(str + 4, strNewChunk(len, len, 0, rawStr));
  return str;
}
fn strDelete(str) {
  let chunk, nextChunk;
  chunk = load(str + 4);
  while (chunk) {
    nextChunk = load(chunk + 8);
    free(chunk);
    chunk = nextChunk;
  }
  free(str);
}
fn strFlatten(str) {
  let len, headChunk, chunkLen, newHeadChunk, chunk, nextChunk, nextChunkLen;
  len = load(str + 0);
  headChunk = load(str + 4);
  chunkLen = load(headChunk + 4);
  if (len == chunkLen) {
    return;
  }
  chunk = load(headChunk + 8);
  // If first headChunk is not large enough to hold entire string, replace it with a
  // new headChunk that has sufficient size.
  if (load(headChunk + 0) < len) {
    newHeadChunk = strNewChunk(len, chunkLen, 0, headChunk + 12);
    free(headChunk);
    headChunk = newHeadChunk;
    store(str + 4, headChunk);
  } else if (chunk) {
    store(headChunk + 8, 0);
  }
  store(headChunk + 4, len);
  while (chunk) {
    nextChunkLen = load(chunk + 4);
    nextChunk = load(chunk + 8);
    if (nextChunkLen) {
      memcpy(headChunk + 12 + chunkLen, chunk + 12, nextChunkLen);
      chunkLen = chunkLen + nextChunkLen;
    }
    free(chunk);
    chunk = nextChunk;
  }
}
fn strToRaw(str): Int {
  let len, chunk, result;
  strFlatten(str);
  len = load(str + 0);
  chunk = load(str + 4);
  result = malloc(len + 1);
  memcpy(result, chunk + 12, len);
  store8(result + len, 0);
  return result;
}
// Append str2 to str1 and delete str2.
fn strMerge(str1, str2): Int {
  let str1Len, str2Len, str1TailChunk, str2HeadChunk, str1TailChunkSize, str1TailChunkLen, str2HeadChunkLen;
  str1Len = load(str1 + 0);
  str2Len = load(str2 + 0);

  // Special case: if both strings are empty, nothing to do.
  if (str1Len == 0 && str2Len == 0) {
    strDelete(str2);
    return str1;
  }

  store(str1 + 0, str1Len + str2Len);
  // Special case: if str1 is empty but str2 isn't, take ownership of str2's
  // chunks.
  if (str1Len == 0) {
    str1TailChunk = load(str1 + 4);
    str2HeadChunk = load(str2 + 4);
    free(str1TailChunk);
    store(str1 + 4, str2HeadChunk);
    free(str2);
    return str1;
  }

  str1TailChunk = strGetTailChunk(str1);
  str2HeadChunk = load(str2 + 4);
  str1TailChunkSize = load(str1TailChunk + 0);
  str1TailChunkLen = load(str1TailChunk + 4);
  str2HeadChunkLen = load(str2HeadChunk + 4);
  if (str1TailChunkLen + str2HeadChunkLen <= str1TailChunkSize) {
    // Merge str2's first chunk with str1's last chunk if possible.
    store(str1TailChunk + 4, str1TailChunkLen + str2HeadChunkLen);
    store(str1TailChunk + 8, load(str2HeadChunk + 8));
    memcpy(str1TailChunk + 12 + str1TailChunkLen, str2HeadChunk + 12, str2HeadChunkLen);
    free(str2HeadChunk);
    free(str2);
  } else {
    // Else, add str2's first chunk after str1's last chunk.
    store(str1TailChunk + 8, str2HeadChunk);
    free(str2);
  }
  return str1;
}
fn strAppendRaw(str1, str2): Int {
  let str1Len, str2Len, str1TailChunk, str1TailChunkSize, str1TailChunkLen, newChunk;
  str2Len = rawStrLen(str2);
  if (str2Len == 0) {
    return str1;
  }
  str1Len = load(str1 + 0);
  store(str1 + 0, str1Len + str2Len);
  str1TailChunk = strGetTailChunk(str1);
  str1TailChunkSize = load(str1TailChunk + 0);
  str1TailChunkLen = load(str1TailChunk + 4);
  if (str1TailChunkLen + str2Len < str1TailChunkSize) {
    // Merge str2 into last str1TailChunk.
    store(str1TailChunk + 4, str1TailChunkLen + str2Len);
    memcpy(str1TailChunk + 12 + str1TailChunkLen, str2, str2Len);
  } else {
    // Create new chunk from str2 and add it after str1TailChunk.
    newChunk = strNewChunk(str2Len, str2Len, 0, str2);
    store(str1TailChunk + 8, newChunk);
  }
  return str1;
}
fn strLen(str): Int {
  return load(str + 0);
}
fn strGetTailChunk(str): Int {
  let chunk, nextChunk, chunkCount;
  chunk = load(str + 4);
  chunkCount = 1;
  while (1) {
    nextChunk = load(chunk + 8);
    if (!nextChunk) {
      return chunk;
    }
    chunkCount = chunkCount + 1;
    if (chunkCount >= 8) {
      strFlatten(str);
      return load(str + 4);
    }
    chunk = nextChunk;
  }
}
fn strNewChunk(minSize, len, next, src): Int {
  let newChunk, newChunkSize;
  newChunkSize = (minSize + 3) / 4 * 4;
  if (newChunkSize < 32) {
    newChunkSize = 32;
  }
  newChunk = malloc(12 + newChunkSize);
  store(newChunk + 0, newChunkSize);
  store(newChunk + 4, len);
  store(newChunk + 8, next);
  if (src) {
    memcpy(newChunk + 12, src, len);
  }
  return newChunk;
}
// Compare str against raw string.
fn strCmpRaw(str1, str2): Int {
  strFlatten(str1);
  return memcmp2(load(str1 + 4) + 12, strLen(str1), str2, rawStrLen(str2));
}
// Compare str against str.
fn strCmp(str1, str2): Int {
  strFlatten(str1);
  strFlatten(str2);
  return memcmp2(load(str1 + 4) + 12, strLen(str1), load(str2 + 4) + 12, strLen(str2));
}

// Raw (i.e., C-style, null terminated) strings.
fn rawStrLen(str): Int {
  let len;
  while (load8_u(str)) {
    len = len + 1;
    str = str + 1;
  }
  return len;
}
fn itoa(n, str): Int {
  let p;
  p = str + 11;
  store8(p, 0);
  while (1) {
    p = p - 1;
    store8(p, n % 10 + 48);
    n = n / 10;
    if (n == 0) {
      break;
    }
  }
  return p;
}
fn memcmp(p1, p2, size): Int {
  let offset, v1, v2;
  if (p1 == p2 || size == 0) {
    return 0;
  }
  offset = 0;
  while (offset < size) {
    v1 = load8_u(p1 + offset);
    v2 = load8_u(p2 + offset);
    if (v1 != v2) {
      return v1 - v2;
    }
    offset = offset + 1;
  }
  return 0;
}
fn memcmp2(p1, p1Size, p2, p2Size): Int {
  if (p1Size < p2Size) {
    return memcmp(p1, p2, p1Size) || -1;
  } else if (p1Size > p2Size) {
    return memcmp(p1, p2, p2Size) || 1;
  }
  return memcmp(p1, p2, p1Size);
}

// Entry point.
fn compileModule(): String {
  return "(module)";
}
fn init(input) {
  // Usable memory is between end of input and 15MB where we'll place string literals.
  memoryInit((input + rawStrLen(input) + 1 + 3) / 4 * 4, 15728640);
}
