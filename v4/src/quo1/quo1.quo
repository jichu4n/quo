// Lexer.
//
// Token types:
//   00 - EOF
//   01 - Number literal
//   02 - String literal
//   03 - Identifier
//   04 - fn
//   05 - let
//   06 - if
//   07 - else
//   08 - while
//   09 - return
//   10 - break
//   11 - continue
// Single letter operators and symbol are their ASCII value. Double letter
// operators are 128 + the ASCII value of the first letter.
let inputPtr;
let keywords;
let twoCharOperators;
fn lexerInit(input) {
  inputPtr = input;
  keywords = dictNew(16);
  // Keywords in the order of their values.
  dictSetRaw(keywords, "fn", 1, 0);
  dictSetRaw(keywords, "let", 1, 0);
  dictSetRaw(keywords, "if", 1, 0);
  dictSetRaw(keywords, "else", 1, 0);
  dictSetRaw(keywords, "while", 1, 0);
  dictSetRaw(keywords, "return", 1, 0);
  dictSetRaw(keywords, "break", 1, 0);
  dictSetRaw(keywords, "continue", 1, 0);
  twoCharOperators = dictNew(16);
  dictSetRaw(twoCharOperators, "==", 1, 0);
  dictSetRaw(twoCharOperators, "!=", 1, 0);
  dictSetRaw(twoCharOperators, "<=", 1, 0);
  dictSetRaw(twoCharOperators, ">=", 1, 0);
  dictSetRaw(twoCharOperators, "&&", 1, 0);
  dictSetRaw(twoCharOperators, "||", 1, 0);
}
fn nextToken(value): Int {
  let c, c2;

  strClear(value);
  skipWhitespaceAndComments();
  c = curChar();

  // EOF
  if (c == 0) {
    return 0;
  }

  // Number literal
  if (isDigit(c)
    || (c == 45 && isDigit(peekNextChar()))) {  // -
    while (1) {
      strPush(value, c);
      c = nextChar();
      if (!isDigit(c)) {
        break;
      }
    }
    return 1;
  }

  // String literal
  if (c == 34) {  // "
    while (1) {
      c = nextChar();
      if (c == 0) {
        throw("Unterminated string literal");
      }
      if (c == 34) {  // "
        break;
      }
      strPush(value, c);
    }
    nextChar();
    return 2;
  }

  // Identifier or keyword.
  if (isIdent(c)) {
    while (isIdent(c)) {
      strPush(value, c);
      c = nextChar();
    }
    return 4 + dictFind(keywords, value);
  }

  // Operators.
  if (strchr("(){}[]<>=+-*/%!&|.,;:^", c)) {
    strPush(value, c);
    strPush(value, nextChar());
    if (dictFind(twoCharOperators, value) >= 0) {
      nextChar();
      return c + 128;
    } else {
      strPop(value);
      return c;
    }
  }

  throw("Unrecognized character");
}
fn skipWhitespaceAndComments() {
  let c;
  c = curChar();
  while (1) {
    if (isSpace(c)) {
      c = nextChar();
    } else if (c == 47 && peekNextChar() == 47) {  // "/"
      nextChar();
      c = nextChar();
      while (c != 10 && c != 0) {  // LF
        c = nextChar();
      }
    } else {
      break;
    }
  }
}
fn nextChar(): Int {
  inputPtr = inputPtr + 1;
  return load8_u(inputPtr);
}
fn peekNextChar(): Int {
  return load8_u(inputPtr + 1);
}
fn curChar(): Int {
  return load8_u(inputPtr);
}
fn isSpace(c): Int {
  return c == 32  // space
    || c == 9     // tab
    || c == 13    // CR
    || c == 10;   // LF
}
fn isDigit(c): Int {
  return c >= 48  // 0
    && c <= 57;   // 9
}
fn isAlpha(c): Int {
  return (c >= 65 && c <= 90) || (c >= 97 && c <= 122);
}
fn isIdent(c): Int {
  return isAlpha(c) || isDigit(c) || c == 95; // _
}
fn strchr(rawStr, c): Int {
  let c2;
  while (1) {
    c2 = load8_u(rawStr);
    if (c2 == 0) {
      return 0;
    }
    if (c == c2) {
      return rawStr;
    }
    rawStr = rawStr + 1;
  }
}


// Entry point.
fn compileModule(): String {
  return "  ;; placeholder";
}
fn indent(indentLevel): String {
  let str, i;
  str = strNew(indentLevel * 2);
  i = 0;
  while (i < indentLevel) {
    strAddRaw(str, "  ");
    i = i + 1;
  }
  return str;
}
fn init(input, memoryEnd) {
  // Usable memory is between end of input and 15MB where we'll place string literals.
  memoryInit((input + rawStrLen(input) + 1 + 3) / 4 * 4, memoryEnd);
  lexerInit(input);
}
