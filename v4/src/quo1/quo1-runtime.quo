// Memory allocation via simple first-fit algorithm.
//
// Chunk header is 16 bytes:
//   0  i32 - chunk size in bytes
//   4  i32 - next chunk header or 0
//   8  i32 - prev chunk header or 0
//   12 byte - used = 1, free = 0
//   16 chunk data
// Minimum chunk data size is 16 bytes (so total 32 bytes with header).
let heapStart;
let heapEnd;
fn memoryInit(start, end) {
  let size, chunk;
  if (start <= 0) {
    throw("Memory cannot start at 0");
  }
  size = end - start;
  if (size < 16) {
    throw("Memory must be greater than 16 bytes");
  }
  heapStart = start;
  heapEnd = end;
  chunk = start;
  store(chunk, heapEnd - heapStart - 16);
  store(chunk + 4, 0);
  store(chunk + 8, 0);
  store8(chunk + 12, 0);
}
fn malloc(size) {
  let sizeWithHeader, chunk, chunkSize, nextChunk, newChunk;
  if (size <= 0) {
    return 0;
  }
  size = (size + 15) / 16 * 16;
  sizeWithHeader = size + 16;
  chunk = heapStart;
  while (chunk != 0) {
    chunkSize = load(chunk);
    nextChunk = load(chunk + 4);
    if (!load8_u(chunk + 12)) {
      if (chunkSize >= size + 32) {
        // Split current chunk and return it.
        //
        // Create new chunk.
        newChunk = chunk + 16 + size;
        store(newChunk, chunkSize - size - 16);
        store(newChunk + 4, nextChunk);
        store(newChunk + 8, chunk);
        store8(newChunk + 12, 0);
        // Update original next chunk.
        if (nextChunk) {
          store(nextChunk + 8, newChunk);
        }
        // Update current chunk.
        store(chunk, size);
        store(chunk + 4, newChunk);
        store8(chunk + 12, 1);
        return chunk + 16;
      } else if (chunkSize >= size) {
        // Just mark current chunk as used and return it
        store8(chunk + 12, 1);
        return chunk + 16;
      }
    }
    chunk = nextChunk;
  }
  throw("Out of memory");
}
fn free(ptr) {
  let chunk, size, prevChunk, nextChunk, nextNextChunk;
  if (ptr == 0 || ptr < heapStart + 16 ||  ptr > heapEnd - 16) {
    return;
  }
  chunk = ptr - 16;
  if (load8_u(chunk + 12) == 0) {
    throw("Double free");
  }
  store8(chunk + 12, 0);
  size = load(chunk + 0);
  nextChunk = load(chunk + 4);
  prevChunk = load(chunk + 8);
  // Merge with prev chunk if prev chunk is free
  if (prevChunk && !load8_u(prevChunk + 12)) {
    chunk = prevChunk;
    size = load(chunk + 0) + size + 16;
    store(chunk + 0, size);
    store(chunk + 4, nextChunk);
    if (nextChunk) {
      store(nextChunk + 8, chunk);
    }
  }
  // Merge with next chunk if next chunk is free
  if (nextChunk && !load8_u(nextChunk + 12)) {
    size = size + load(nextChunk + 0) + 16;
    store(chunk + 0, size);
    nextNextChunk = load(nextChunk + 4);
    store(chunk + 4, nextNextChunk);
    if (nextNextChunk) {
      store(nextNextChunk + 8, chunk);
    }
  }
}

// Strings.
//
// Strings are represented as a header and a linked list of chunks. This
// representation helps reduce copying when building strings, which is a common
// operation during compilation.
//
// A string must have at least 1 chunk and at most 8 chunks.
// Each chunk starts off with at least 32 bytes and grows by a factor of 2.
//
// String header is 8 bytes:
//   00 i32 - string length
//   04 i32 - first chunk address (always non-null)
//
//  Chunk header is 12 bytes:
//    00 i32 - chunk size
//    04 i32 - length of string in chunk
//    08 i32 - next chunk address, 0 if last chunk
//    12 data
fn strNew(reserveLen) {
  let str;
  str = malloc(8);
  store(str + 0, 0);
  store(str + 4, strNewChunk(reserveLen, 0, 0, 0));
  return str;
}
fn strFromRaw(rawStr) {
  let len, str;
  len = rawStrLen(rawStr);
  str = malloc(8);
  store(str + 0, len);
  store(str + 4, strNewChunk(len, len, 0, rawStr));
  return str;
}
fn strDelete(str) {
  let chunk, nextChunk;
  chunk = load(str + 4);
  while (chunk) {
    nextChunk = load(chunk + 8);
    free(chunk);
    chunk = nextChunk;
  }
  free(str);
}
fn strClear(str) {
  let headChunk, chunk, nextChunk;
  headChunk = load(str + 4);
  chunk = load(headChunk + 8);
  while (chunk) {
    nextChunk = load(chunk + 8);
    free(chunk);
    chunk = nextChunk;
  }
  store(str + 0, 0);
  store(headChunk + 4, 0);
  store(headChunk + 8, 0);
}
fn strFlatten(str) {
  let len, headChunk, chunkLen, newHeadChunk, chunk, nextChunk, nextChunkLen;
  len = load(str + 0);
  headChunk = load(str + 4);
  chunkLen = load(headChunk + 4);
  if (len == chunkLen) {
    return;
  }
  chunk = load(headChunk + 8);
  // If first headChunk is not large enough to hold entire string, replace it with a
  // new headChunk that has sufficient size.
  if (load(headChunk + 0) < len) {
    newHeadChunk = strNewChunk(len, chunkLen, 0, headChunk + 12);
    free(headChunk);
    headChunk = newHeadChunk;
    store(str + 4, headChunk);
  } else if (chunk) {
    store(headChunk + 8, 0);
  }
  store(headChunk + 4, len);
  while (chunk) {
    nextChunkLen = load(chunk + 4);
    nextChunk = load(chunk + 8);
    if (nextChunkLen) {
      memcpy(headChunk + 12 + chunkLen, chunk + 12, nextChunkLen);
      chunkLen = chunkLen + nextChunkLen;
    }
    free(chunk);
    chunk = nextChunk;
  }
}
fn strToRaw(str) {
  let len, chunk, result;
  strFlatten(str);
  len = load(str + 0);
  chunk = load(str + 4);
  result = malloc(len + 1);
  memcpy(result, chunk + 12, len);
  store8(result + len, 0);
  return result;
}
// Append str2 to str1 and delete str2.
fn strMerge(str1, str2) {
  let str1Len, str2Len, str1TailChunk, str2HeadChunk, str1TailChunkSize, str1TailChunkLen, str2HeadChunkLen;
  str1Len = load(str1 + 0);
  str2Len = load(str2 + 0);

  // Special case: if both strings are empty, nothing to do.
  if (str1Len == 0 && str2Len == 0) {
    strDelete(str2);
    return str1;
  }

  // Special case: if str1 is empty but str2 isn't, take ownership of str2's
  // chunks.
  if (str1Len == 0) {
    str1TailChunk = load(str1 + 4);
    str2HeadChunk = load(str2 + 4);
    free(str1TailChunk);
    store(str1 + 0, str1Len + str2Len);
    store(str1 + 4, str2HeadChunk);
    free(str2);
    return str1;
  }

  str1TailChunk = strGetTailChunk(str1);
  str2HeadChunk = load(str2 + 4);
  str1TailChunkSize = load(str1TailChunk + 0);
  str1TailChunkLen = load(str1TailChunk + 4);
  str2HeadChunkLen = load(str2HeadChunk + 4);
  if (str1TailChunkLen + str2HeadChunkLen <= str1TailChunkSize) {
    // Merge str2's first chunk with str1's last chunk if possible.
    store(str1TailChunk + 4, str1TailChunkLen + str2HeadChunkLen);
    store(str1TailChunk + 8, load(str2HeadChunk + 8));
    memcpy(str1TailChunk + 12 + str1TailChunkLen, str2HeadChunk + 12, str2HeadChunkLen);
    free(str2HeadChunk);
    free(str2);
  } else {
    // Else, add str2's first chunk after str1's last chunk.
    store(str1TailChunk + 8, str2HeadChunk);
    free(str2);
  }
  store(str1 + 0, str1Len + str2Len);
  return str1;
}
fn strPush(str1, str2) {
  return strMerge(str1, strClone(str2));
}
fn strPushRaw(str1, str2) {
  let str1Len, str2Len, str1TailChunk, str1TailChunkSize, str1TailChunkLen, newChunk;
  str2Len = rawStrLen(str2);
  if (str2Len == 0) {
    return str1;
  }
  str1Len = load(str1 + 0);
  str1TailChunk = strGetTailChunk(str1);
  str1TailChunkSize = load(str1TailChunk + 0);
  str1TailChunkLen = load(str1TailChunk + 4);
  store(str1 + 0, str1Len + str2Len);
  if (str1TailChunkLen + str2Len <= str1TailChunkSize) {
    // Merge str2 into last str1TailChunk.
    store(str1TailChunk + 4, str1TailChunkLen + str2Len);
    memcpy(str1TailChunk + 12 + str1TailChunkLen, str2, str2Len);
  } else {
    // Create new chunk from str2 and add it after str1TailChunk.
    newChunk = strNewChunk(str2Len, str2Len, 0, str2);
    store(str1TailChunk + 8, newChunk);
  }
  return str1;
}
fn strFromChar(c) {
  let str, chunk;
  str = strNew(1);
  chunk = strGetTailChunk(str);
  store(str + 0, 1);
  store(chunk + 4, 1);
  store8(chunk + 12, c);
  return str;
}
fn strPushChar(str1, c) {
  return strMerge(str1, strFromChar(c));
}
fn strPop(str) {
  let len, tailChunk, tailChunkLen;
  len = strLen(str);
  if (len < 1) {
    return 0;
  }
  tailChunk = strGetTailChunk(str);
  tailChunkLen = load(tailChunk + 4);
  store(str + 0, len - 1);
  store(tailChunk + 4, tailChunkLen - 1);
  return load8_u(tailChunk + 12 + tailChunkLen - 1);
}
fn strLen(str) {
  return load(str + 0);
}
fn strGetTailChunk(str) {
  let chunk, nextChunk, chunkCount;
  chunk = load(str + 4);
  chunkCount = 1;
  while (1) {
    nextChunk = load(chunk + 8);
    if (!nextChunk) {
      return chunk;
    }
    chunkCount = chunkCount + 1;
    if (chunkCount >= 8) {
      strFlatten(str);
      return load(str + 4);
    }
    chunk = nextChunk;
  }
}
fn strNewChunk(minSize, len, next, src) {
  let newChunk, newChunkSize;
  newChunkSize = (minSize + 3) / 4 * 4;
  if (newChunkSize < 32) {
    newChunkSize = 32;
  }
  newChunk = malloc(12 + newChunkSize);
  store(newChunk + 0, newChunkSize);
  store(newChunk + 4, len);
  store(newChunk + 8, next);
  if (src) {
    memcpy(newChunk + 12, src, len);
  }
  return newChunk;
}
// Compare str against raw string.
fn strCmpRaw(str1, str2) {
  strFlatten(str1);
  return memcmp2(load(str1 + 4) + 12, strLen(str1), str2, rawStrLen(str2));
}
// Compare str against str.
fn strCmp(str1, str2) {
  strFlatten(str1);
  strFlatten(str2);
  return memcmp2(load(str1 + 4) + 12, strLen(str1), load(str2 + 4) + 12, strLen(str2));
}
fn strClone(str) {
  let len, newStr, newChunk, chunk;
  strFlatten(str);
  len = strLen(str);
  newStr = strNew(len);
  store(newStr + 0, len);
  chunk = load(str + 4);
  newChunk = load(newStr + 4);
  store(newChunk + 4, len);
  memcpy(newChunk + 12, chunk + 12, len);
  return newStr;
}
fn strFromInt(n) {
  let rawStr, str;
  rawStr = malloc(16);
  str = strFromRaw(itoa(n, rawStr));
  free(rawStr);
  return str;
}
fn strPushInt(str1, n) {
  return strMerge(str1, strFromInt(n));
}

// Arrays - logically equivalent to Array<number>.
//
// Arrays are represented as a classic dynamic array, i.e. the equivalent of a
// C++ vector. Each element is an i32.
//
// Array header is 12 bytes:
//   00 i32 size - allocated ize in number of elements, so size in bytes is size * 4.
//   04 i32 len - number of elements in use.
//   08 i32 data - address of data
// So address of element k is data + k * 4.
fn arrNew(reserveLen) {
  let arr, size, data;
  if (reserveLen < 4) {
    size = 4;
  } else {
    size = reserveLen;
  }
  arr = malloc(12);
  store(arr + 0, size);
  store(arr + 4, 0);
  store(arr + 8, malloc(size * 4));
  return arr;
}
fn arrDelete(arr, shouldFreeValues) {
  arrClear(arr, shouldFreeValues);
  free(load(arr + 8));
  free(arr);
}
fn arrPush(arr, elem) {
  let size, len, data, newSize, newData;
  size = load(arr + 0);
  len = load(arr + 4);
  data = load(arr + 8);
  if (len > size) {
    throw("Array len exceeds size");
  }
  if (len == size) {
    newSize = size * 2;
    newData = malloc(newSize * 4);
    memcpy(newData, data, size * 4);
    free(data);
    store(arr + 0, newSize);
    store(arr + 8, newData);
    data = newData;
  }
  store(arr + 4, len + 1);
  store(data + len * 4, elem);
}
fn arrLen(arr) {
  return load(arr + 4);
}
fn arrClear(arr, shouldFreeValues) {
  let len, data, i;
  if (shouldFreeValues) {
    len = load(arr + 4);
    data = load(arr + 8);
    i = 0;
    while (i < len) {
      free(load(data + i * 4));
      i = i + 1;
    }
  }
  store(arr + 4, 0);
}
fn arrGet(arr, i) {
  if (i < 0 || i >= arrLen(arr)) {
    throw("Array index out of bounds");
  }
  return load(load(arr + 8) + i * 4);
}
fn arrSet(arr, i, v) {
  if (i < 0 || i >= arrLen(arr)) {
    throw("Array index out of bounds");
  }
  store(load(arr + 8) + i * 4, v);
}

// Dict - logically equivalent to Map<string, number>.
//
// The implementation uses two arrays, one for keys and one for values. Lookup
// is done by searching in the keys array and returning the value at the same
// index. This is quite inefficient obviously, i.e. O(key count * key length),
// but meh.
//
// Dict header is 8 bytes:
//   00 i32 - address of keys array
//   04 i32 - address of values array
fn dictNew(reserveLen) {
  let dict;
  dict = malloc(8);
  store(dict + 0, arrNew(reserveLen));
  store(dict + 4, arrNew(reserveLen));
  return dict;
}
fn dictClear(dict, shouldFreeValues) {
  let len, i, keys, values;
  keys = load(dict + 0);
  values = load(dict + 4);
  len = arrLen(keys);
  i = 0;
  while (i < len) {
    strDelete(arrGet(keys, i));
    i = i + 1;
  }
  arrClear(keys, 0);
  arrClear(values, shouldFreeValues);
}
fn dictDelete(dict, shouldFreeValues) {
  let keys, values;
  keys = load(dict + 0);
  values = load(dict + 4);
  dictClear(dict, shouldFreeValues);
  arrDelete(keys, 0);
  arrDelete(values, 0);
  free(dict);
}
fn dictFind(dict, str) {
  let len, i, keys, values;
  keys = load(dict + 0);
  len = arrLen(keys);
  i = 0;
  while (i < len) {
    if (strCmp(str, arrGet(keys, i)) == 0) {
      return i;
    }
    i = i + 1;
  }
  return -1;
}
fn dictGet(dict, key) {
  let i, values;
  i = dictFind(dict, key);
  if (i >= 0) {
    values = load(dict + 4);
    return arrGet(values, i);
  }
  // This is rather awkward - since dict is storing i32 values, there are
  // no obvious ways to return an invalid value. But we'll mostly be using
  // dict to store pointers, so 0 i.e. null is the most reasonable result.
  return 0;
}
fn dictSet(dict, key, v, shouldFreeOldValue) {
  let len, i, keys, values, newKey;
  keys = load(dict + 0);
  values = load(dict + 4);
  len = arrLen(keys);
  i = dictFind(dict, key);
  if (i < 0) {
    i = len;
    newKey = strClone(key);
    arrPush(keys, newKey);
    arrPush(values, v);
  } else {
    if (shouldFreeOldValue) {
      free(arrGet(values, i));
    }
    arrSet(values, i, v);
  }
}
fn dictSetRaw(dict, rawKey, v, shouldFreeOldValue) {
  let key;
  key = strFromRaw(rawKey);
  dictSet(dict, key, v, shouldFreeOldValue);
  strDelete(key);
}
fn dictLen(dict) {
  let keys;
  keys = load(dict + 0);
  return arrLen(keys);
}
fn dictGetKeyAt(dict, i) {
  let keys;
  keys = load(dict + 0);
  return arrGet(keys, i);
}
fn dictGetValueAt(dict, i) {
  let values;
  values = load(dict + 4);
  return arrGet(values, i);
}


// Raw (i.e., C-style, null terminated) strings.
fn rawStrLen(str) {
  let len;
  while (load8_u(str)) {
    len = len + 1;
    str = str + 1;
  }
  return len;
}
fn itoa(n, rawStr) {
  let p;
  p = rawStr + 11;
  store8(p, 0);
  while (1) {
    p = p - 1;
    store8(p, n % 10 + 48);
    n = n / 10;
    if (n == 0) {
      break;
    }
  }
  return p;
}
fn memcmp(p1, p2, size) {
  let offset, v1, v2;
  if (p1 == p2 || size == 0) {
    return 0;
  }
  offset = 0;
  while (offset < size) {
    v1 = load8_u(p1 + offset);
    v2 = load8_u(p2 + offset);
    if (v1 != v2) {
      return v1 - v2;
    }
    offset = offset + 1;
  }
  return 0;
}
fn memcmp2(p1, p1Size, p2, p2Size) {
  if (p1Size < p2Size) {
    return memcmp(p1, p2, p1Size) || -1;
  } else if (p1Size > p2Size) {
    return memcmp(p1, p2, p2Size) || 1;
  }
  return memcmp(p1, p2, p1Size);
}
